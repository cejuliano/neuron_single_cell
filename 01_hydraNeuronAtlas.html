<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Hannah Morris Little &amp; Abby S. Primack" />


<title>Aligning, Processing, and Analyzing Hydra Neuron 10x scRNA-seq Data</title>

<script src="01_hydraNeuronAtlas_files/header-attrs-2.26/header-attrs.js"></script>
<script src="01_hydraNeuronAtlas_files/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="01_hydraNeuronAtlas_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="01_hydraNeuronAtlas_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="01_hydraNeuronAtlas_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="01_hydraNeuronAtlas_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="01_hydraNeuronAtlas_files/navigation-1.1/tabsets.js"></script>
<link href="01_hydraNeuronAtlas_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="01_hydraNeuronAtlas_files/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div id="header">



<h1 class="title toc-ignore">Aligning, Processing, and Analyzing
<em>Hydra</em> Neuron 10x scRNA-seq Data</h1>
<h4 class="author">Hannah Morris Little &amp; Abby S. Primack</h4>

</div>


<p>This document covers the mapping of the Neuron Enriched
<em>Hydra</em> 10x scRNA-seq data collected for this study to the stain
AEP <em>H.vulgaris</em> genome as a reference followed by cluster
analysis of this 10x dataset integrated with the neuron Drop-seq data
originally published in <a
href="https://www.science.org/doi/10.1126/science.aav9314">Siebert et
al. (2019)</a> (raw data available <a
href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE121617">here</a>)
and re-mapped/re-analyzed in <a
href="https://genome.cshlp.org/content/early/2023/02/23/gr.277040.122">Cazet
et al. (2023)</a> (processed data can be downloaded from the
05_hydraAtlasReMap repo on the Hydra AEP Genome Project Portal under the
<a
href="https://research.nhgri.nih.gov/HydraAEP/download/index.cgi?dl=fa">Scripts
and Data tab</a>). This document covers initial read mapping, cell
filtering and QC, clustering, plotting, co-expression analysis, and
final annotation of the <em>Hydra</em> Neuron scRNA-seq data.</p>
<p><strong>Aligning, Processing, and Analyzing <em>Hydra</em> Neuron 10x
scRNA-seq Data</strong><br> <a href="#item-one">Mapping 10x Data to the
AEP Assembly Transcriptome</a><br> <a href="#item-two">QC, Filtering,
and Removal of nonNeuronal Cells from 10X single cell libraries</a><br>
<a href="#item-three">Initial Integration and Clustering</a><br> <a
href="#item-four">Final Integration and Clustering</a><br> <a
href="#item-five">Annotating the Hydra Neuron Single Cell Atlas</a><br>
<a href="#item-six">Identifying Gene Co-Expression Programs Using
Non-Negative Matrix Factorization</a><br> <a
href="#item-seven">Interactive 3D UMAP of Final Hydra Neuron Single Cell
Atlas</a><br> <a href="#item-eight">Files Associated with this
Document</a><br></p>
<!-- headings -->
<a id="item-one"></a>
<h3>
Mapping 10x Data to the AEP Assembly Transcriptome
</h3>
<p>To map our raw 10x reads to the AEP assembly, we used the Cell Ranger
pipeline from 10x Genomics (cellranger v.6.1.1)<br></p>
<p>First, the 01_mapping/cellranger_mkref.sh script was used to prep the
reference files for mapping. We used the transcript sequences for the
longest isoforms for each gene (<code>HVAEP1.tran.longestIso.fa</code>).
We opted to use transcriptomic sequence as opposed to genomic sequence
because it eliminated the possibility of mapping to off-target intronic
and intergenic regions. We also supplemented these sequences with
mitochondrial genes, whose expression levels can provide a useful
readout of stress in a cell. The final file was called
<code>HVAEP1.tran.final.mito.fasta</code>. We provided the gtf file
(<code>HVAEP1.transcriptome.mito.gtf</code>) as the cellranger pipeline
requires a gtf file for the reference sequence, even if it’s not a
genomic sequence.<br></p>
<p>(<em>01_mapping/cellranger_mkref.sh</em>)</p>
<pre><code>#!/bin/bash -l
#SBATCH --job-name=cellrangerref
#SBATCH -c 12
#SBATCH --mem=10G
#SBATCH -t 1-00:00
#SBATCH --error=logs/10x_ref.err
#SBATCH --output=logs/10x_ref.out

export PATH=/group/julianolab/analyses/dropseq/cellranger-6.1.1:$PATH

cellranger mkref \
--genome=HVAEP1.tran.final.mito.10x.ref \
--fasta=resources/HVAEP1.tran.final.mito.fasta \
--genes=resources/HVAEP1.transcriptome.mito.gtf</code></pre>
<p>We used a series of 01/cellranger_count_*.sh scripts to align 10x
sequencing reads from individual libraries to the 10x reference
transcriptome created by the previous script to produce raw and filtered
feature-barcode matrices.<br></p>
<p>(<em>01_mapping/cellranger_count_bud1.sh</em>)</p>
<pre><code>#!/bin/bash -l
#SBATCH --job-name=bud1_10x_count
#SBATCH -c 24
#SBATCH --mem=40G
#SBATCH -t 2-00:00:00
#SBATCH --error=logs/budding_10x_1.err
#SBATCH --output=logs/budding_10x_1.out


# ======================================== #
### DEFINE PATHS NEEDED FOR THE PIPELINE ###
# ======================================== #

export PATH=/group/julianolab/analyses/dropseq/cellranger-6.1.1:$PATH

cellranger count \
--id=budding1_10x_HVAEP1_tran_final \
--fastqs=raw_data/budding_fastq/ \
--sample=ACTIN_GFP_1 \
--transcriptome=HVAEP1.tran.final.mito.10x.ref/ \</code></pre>
<p>(<em>01_mapping/cellranger_count_bud2.sh</em>)</p>
<pre><code>#!/bin/bash -l
#SBATCH --job-name=bud2_10x_count
#SBATCH -c 24
#SBATCH --mem=40G
#SBATCH -t 2-00:00:00
#SBATCH --error=logs/budding_10x_2.err
#SBATCH --output=logs/budding_10x_2.out


# ======================================== #
### DEFINE PATHS NEEDED FOR THE PIPELINE ###
# ======================================== #

export PATH=/group/julianolab/analyses/dropseq/cellranger-6.1.1:$PATH

cellranger count \
--id=budding2_10x_HVAEP1_tran_final \
--fastqs=raw_data/budding_fastq/ \
--sample=ACTIN_GFP_2 \
--transcriptome=HVAEP1.tran.final.mito.10x.ref/ \</code></pre>
<p>(<em>01_mapping/cellranger_count_nG.sh</em>)</p>
<pre><code>#!/bin/bash -l
#SBATCH --job-name=nG10x_count
#SBATCH -c 24
#SBATCH --mem=40G
#SBATCH -t 2-00:00:00
#SBATCH --error=logs/nG_10x.err
#SBATCH --output=logs/nG_10x.out


# ======================================== #
### DEFINE PATHS NEEDED FOR THE PIPELINE ###
# ======================================== #

export PATH=/group/julianolab/analyses/dropseq/cellranger-6.1.1:$PATH

cellranger count \
--id=nGreen_10x_HVAEP1_tran_final \
--fastqs=raw_data/ACTIN_GFP_fastqs/ \
--transcriptome=HVAEP1.tran.final.mito.10x.ref/ \</code></pre>
<p>(<em>01_mapping/cellranger_count_PN.sh</em>)</p>
<pre><code>#!/bin/bash -l
#SBATCH --job-name=PN_10x_count
#SBATCH -c 24
#SBATCH --mem=40G
#SBATCH -t 2-00:00:00
#SBATCH --error=logs/PN_10x.err
#SBATCH --output=logs/PN_10x.out


# ======================================== #
### DEFINE PATHS NEEDED FOR THE PIPELINE ###
# ======================================== #

export PATH=/group/julianolab/analyses/dropseq/cellranger-6.1.1:$PATH

cellranger count \
--id=PN_10x_HVAEP1_tran_final \
--fastqs=raw_data/PN_fastqs/ \
--transcriptome=HVAEP1.tran.final.mito.10x.ref/ \</code></pre>
<p>An average overall transcriptome alignment rate of 59.9% was obtained
(PN 62.5%, nGreen 58.6%, nGreen budding1 60.4%, nGreen budding2
58.1%).</p>
<!-- headings -->
<a id="item-two"></a>
<h3>
QC, Filtering, and Removal of nonNeuronal Cells from 10X single cell
libraries
</h3>
<p>We imported the mapped 10x scRNA-seq data as well the subsetted
drop-seq data collected from Siebert et al. 2019 and realigned to the
AEP genome in Cazet et al 2023 into Seurat (v4.0.5) for downstream
cluster analysis and cell type annotation. All of this was done within
one large R script (hydra.neuronSeurat.R). For the purposes of this
document, we have broken this script into chunks to simplify the
explanation process.<br></p>
<p>We imported the 10x scRNA-seq data from the
filtered_feature_bc_matrix folder for each 10x library and the subsetted
drop-seq data collected from Siebert et al. 2019 and realigned to the
AEP genome in Cazet et al 2023 into Seurat (v4.0.5). We performed
initial filtering to remove low quality cells by by removing barcodes
with fewer than 300 or greater than 7,000 unique molecular identifiers
(UMIs), or fewer than 500 or greater than 50,000 reads, or greater than
5% mitochondrial reads.<br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)
<!-- Figure out directory structure -->
<!-- Figure out where in the directory to put the ds neuro object --></p>
<pre class="r"><code># Load packages and set working directory ---------------------------------------------------
# Load packages. This only needs to be done once. 

library(tidyverse)
library(Seurat)
library(grid)
library(gridExtra)
library(ggplot2)
library(patchwork)
library(ggtext)
library(rstudioapi)
library(dplyr)

# Set working directory to the path this script is in
setwd(dirname(getActiveDocumentContext()$path))

# Load raw matrix from each single cell library ----------------------------------------------------

# Here, we are loading the filtered_feature_bc_matrix folder for each 10x library as well the subsetted drop-seq data collected from Siebert et al. 2019 and realigned to the AEP genome in Cazet et al 2023. 10x matrixes were generated by the &quot;cellranger count&quot; function in commandline 

#Load the 10x data from the Tg(actin1:GFP) budding_1 library
nGreen_budding1_10x &lt;-Read10X(data.dir = &quot;unprocessed_data/budding1_filtered_feature_bc_matrix/&quot;)
#Remove HVAEP1_ prefix from gene names
nGreen_budding1_10x@Dimnames[[1]] &lt;- gsub(&quot;HVAEP1_&quot;, &quot;&quot;, nGreen_budding1_10x@Dimnames[[1]])

#Load the 10x data from the Tg(actin1:GFP) budding_2 library
nGreen_budding2_10x &lt;-Read10X(data.dir = &quot;unprocessed_data/budding2_filtered_feature_bc_matrix/&quot;)
#Remove HVAEP1_ prefix from gene names
nGreen_budding2_10x@Dimnames[[1]] &lt;- gsub(&quot;HVAEP1_&quot;, &quot;&quot;, nGreen_budding2_10x@Dimnames[[1]])

#Load the 10x data from the Tg(tba1c:mNeonGreen) library
PN_10x &lt;-Read10X(data.dir = &quot;unprocessed_data/tba1c_filtered_feature_bc_matrix/&quot;)
#Remove HVAEP1_ prefix from gene names
PN_10x@Dimnames[[1]] &lt;- gsub(&quot;HVAEP1_&quot;, &quot;&quot;, PN_10x@Dimnames[[1]])

#Load the 10x data from the Tg(actin1:GFP) non-budding library
nGreen_10x &lt;-Read10X(data.dir =&quot;unprocessed_data/nonbudding_filtered_feature_bc_matrix/&quot;)
#Remove HVAEP1_ prefix from gene names
nGreen_10x@Dimnames[[1]] &lt;- gsub(&quot;HVAEP1_&quot;, &quot;&quot;, nGreen_10x@Dimnames[[1]])

#Load subset from the previously published drop-seq data (Siebert et al. 2019). This table contains cells subsetted from the whole animal data set and contains interstitial stem cells, neuronal progentiors, and differented neurons
ds.neuro.cells &lt;- read.table(file = &quot;unprocessed_data/dsNeuroCells.tsv&quot;, sep = &#39;\t&#39;, header = TRUE)
#Remove HVAEP1- prefix from gene names
rownames(ds.neuro.cells) &lt;- gsub(&quot;HVAEP1-&quot;, &quot;&quot;, rownames(ds.neuro.cells) )


# Next we will perform an initial quality control for each library

# 10x nGreen non-budding Quality Control -------------------------------------------------

# Individual Seurat objects were generated from each library and were filtered as previously described to retain cells with between 300 - 7,000 uniquely expressed genes, 500 - 50,000 transcripts, and less than 5% mitochondrial reads (Satija et al., 2015; Siebert et al., 2019).

# Create Seurat object with the raw counts, keeping all genes expressed in 3 or more cells and all cells with 200 or more transcripts
nGreen_10x_raw &lt;- CreateSeuratObject(counts = nGreen_10x, project = &quot;neonGreen&quot;, min.cells = 3, min.features = 200)

# Calculate percentage of mitochondrial reads per cell and add data to Suerat object
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
nGreen_10x_raw[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(nGreen_10x_raw, pattern = &quot;^MT-&quot;)

# Visualize QC metrics as a violin plot, saved 6 x 14 nG_vlnplot_presubset
VlnPlot(nGreen_10x_raw, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3)</code></pre>
<!-- You need to dump all these images in a resources folder within the project directory (not indiv analysis directory)-->
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/nG_vlnplot_presubset.png"
alt="QC: nG" />
<div class="figcaption">QC: nG</div>
</div>
<pre class="r"><code># Quantify how many cells are over 5% mt? 2 cells
count(nGreen_10x_raw[[&quot;percent.mt&quot;]], percent.mt &gt; 5)

# Subset cells that have between 300 - 7,000 unique features (genes), between 500 - 50,000 counts (transcripts), and less than 5% mitochondrial reads
nGreen &lt;- subset(nGreen_10x_raw, subset = nFeature_RNA &gt; 300 &amp; nFeature_RNA &lt; 7000 &amp; nCount_RNA &gt; 500 &amp; nCount_RNA &lt; 50000 &amp; percent.mt &lt; 5)</code></pre>
<!-- Don't include the saveRDS-->
<pre class="r"><code># 10x nGreen budding_1 Quality Control -------------------------------------------------

# Individual Seurat objects were generated from each library and were filtered as previously described to retain cells with between 300 - 7,000 uniquely expressed genes, 500 - 50,000 transcripts, and less than 5% mitochondrial reads (Satija et al., 2015; Siebert et al., 2019).

# Create Seurat object with the raw counts, keeping all genes expressed in 3 or more cells and all cells with 200 or more transcripts 
nGreen_budding1_10x_raw &lt;- CreateSeuratObject(counts = nGreen_budding1_10x, project = &quot;budding1&quot;, min.cells = 3, min.features = 200)

# Calculate percentage of mitochondrial reads per cell and add data to Suerat object
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
nGreen_budding1_10x_raw[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(nGreen_budding1_10x_raw, pattern = &quot;^MT-&quot;)

# Visualize QC metrics as a violin plot, saved 6 x 14 budding1_vlnplot_presubset
VlnPlot(nGreen_budding1_10x_raw, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3)</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/budding1_vlnplot_presubset.png"
alt="QC: Budding1" />
<div class="figcaption">QC: Budding1</div>
</div>
<pre class="r"><code># Quantify how many cells are over 5% mt? 186 cells
count(nGreen_budding1_10x_raw[[&quot;percent.mt&quot;]], percent.mt &gt; 5)

# Subset cells that have between 300 - 7,000 unique features (genes), between 500 - 50,000 counts (transcripts), and less than 5% mitochondrial reads
nGreen_budding1 &lt;- subset(nGreen_budding1_10x_raw, subset = nFeature_RNA &gt; 300 &amp; nFeature_RNA &lt; 7000 &amp; nCount_RNA &gt; 500 &amp; nCount_RNA &lt; 50000 &amp; percent.mt &lt; 5)</code></pre>
<pre class="r"><code># Create Seurat object with the raw counts, keeping all genes expressed in 3 or more cells and all cells with 200 or more transcripts
nGreen_budding2_10x_raw &lt;- CreateSeuratObject(counts = nGreen_budding2_10x, project = &quot;budding2&quot;, min.cells = 3, min.features = 200)

# Calculate percentage of mitochondrial reads per cell and add data to Suerat object
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
nGreen_budding2_10x_raw[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(nGreen_budding2_10x_raw, pattern = &quot;^MT-&quot;)

# Visualize QC metrics as a violin plot, saved 6 x 14 budding2_vlnplot_presubset
VlnPlot(nGreen_budding2_10x_raw, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3)</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/budding2_vlnplot_presubset.png"
alt="QC: Budding2" />
<div class="figcaption">QC: Budding2</div>
</div>
<pre class="r"><code># Quantify how many cells are over 5% mt? 173 cells
count(nGreen_budding2_10x_raw[[&quot;percent.mt&quot;]], percent.mt &gt; 5)

# Subset cells that have between 300 - 7,000 unique features (genes), between 500 - 50,000 counts (transcripts), and less than 5% mitochondrial reads
nGreen_budding2 &lt;- subset(nGreen_budding2_10x_raw, subset = nFeature_RNA &gt; 300 &amp; nFeature_RNA &lt; 7000 &amp; nCount_RNA &gt; 500 &amp; nCount_RNA &lt; 50000 &amp; percent.mt &lt; 5)</code></pre>
<pre class="r"><code># 10x Pan neuronal Quality Control -------------------------------------------------

# Individual Seurat objects were generated from each library and were filtered as previously described to retain cells with between 300 - 7,000 uniquely expressed genes, 500 - 50,000 transcripts, and less than 5% mitochondrial reads (Satija et al., 2015; Siebert et al., 2019).

# Create Seurat object with the raw counts, keeping all genes expressed in 3 or more cells and all cells with 200 or more transcripts
PN_raw &lt;- CreateSeuratObject(counts = PN_10x, project = &quot;Pan-neuro&quot;, min.cells = 3, min.features = 200)

# Calculate percentage of mitochondrial reads per cell and add data to Suerat object
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
PN_raw[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(PN_raw, pattern = &quot;^MT-&quot;)

# Visualize QC metrics as a violin plot, saved 6 x 14 PN_vlnplot_presubset
VlnPlot(PN_raw, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3)</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/PN_vlnplot_presubset.png"
alt="QC: PN" />
<div class="figcaption">QC: PN</div>
</div>
<pre class="r"><code># Quantify how many cells are over 5% mt? 10 cells
count(PN_raw[[&quot;percent.mt&quot;]], percent.mt &gt; 5)

# Subset cells that have between 300 - 7,000 unique features (genes), between 500 - 50,000 counts (transcripts), and less than 5% mitochondrial reads
PN &lt;- subset(PN_raw, subset = nFeature_RNA &gt; 300 &amp; nFeature_RNA &lt; 7000 &amp; nCount_RNA &gt; 500 &amp; nCount_RNA &lt; 50000 &amp; percent.mt &lt; 5)</code></pre>
<pre class="r"><code># Drop-seq Quality Control  ----------------------------------------------

# Individual Seurat objects were generated from each library and were filtered as previously described to retain cells with between 300 - 7,000 uniquely expressed genes, 500 - 50,000 transcripts, and less than 5% mitochondrial reads (Satija et al., 2015; Siebert et al., 2019).

# Before we create our Seurat object, we must change the naming scheme of the cell identity so that each name is separated by an underscore instead of a mix of periods and underscores

# Using regular expression, change all of the periods to underscores in the column names
names(ds.neuro.cells) &lt;- gsub(&quot;[:.:]&quot;, &quot;_&quot;, names(ds.neuro.cells))

# Create Seurat object with the raw counts, keeping all genes expressed in 3 or more cells and all cells with 200 or more transcripts. We indicate that the library each cell originated from is located in fields 2:4, and the naming fields are seperated by underscores. 
ds.neuro_raw &lt;- CreateSeuratObject(counts = ds.neuro.cells, project = &quot;dropseq&quot;, names.field = 2:4, names.delim = &quot;_&quot;, min.cells = 3, min.features = 200)

# Calculate percentage of mitochondrial reads per cell and add data to Suerat object
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
ds.neuro_raw[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(ds.neuro_raw, pattern = &quot;^MT-&quot;)

# Visualize QC metrics as a violin plot, saved 6 x 14 dsNeuro_vlnplot_presubset
VlnPlot(ds.neuro_raw, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3)</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/dsNeuro_vlnplot_presubset.png"
alt="QC: DropSeq" />
<div class="figcaption">QC: DropSeq</div>
</div>
<pre class="r"><code># Quantify how many cells are over 5% mt? none
count(ds.neuro_raw[[&quot;percent.mt&quot;]], percent.mt &gt; 5)

# Subset cells that have between 300 - 7,000 unique features (genes), between 500 - 50,000 counts (transcripts), and less than 5% mitochondrial reads
ds.neuro &lt;- subset(ds.neuro_raw, subset = nFeature_RNA &gt; 300 &amp; nFeature_RNA &lt; 7000 &amp; nCount_RNA &gt; 500 &amp; nCount_RNA &lt; 50000 &amp; percent.mt &lt; 5)</code></pre>
<p>We then performed a basic cluster analysis of the four new 10X
libraries by performing Louvain clustering on the filtered objects and
generating UMAPs for each. Next we sought to remove any cells that were
neither a neuronal type cell (neural progenitors/precursors and
differentiated neurons) nor interstitial stem cells (ISCs), the stem
cell population neurons are derived from in <em>Hydra</em>. First,
neuronal clusters and ISCs were identified using the following markers:
<em>elav2</em> (G004515) neurons and neural progenitors marker,
<em>tba1c</em> (G019559) pan-neuronal marker, and <em>hy-icell1</em>
(G002332) ISC marker. We identified clusters lacking any of the
neuronal/ISC markers in the libraries collected from
Tg(actin1:GFP)<sup>rs3-in</sup> (formerly named nGreen/neuronGreen)
animals (libraries nGreen, nGreen_budding1, nGreen_budding2).
Tg(actin1:GFP)<sup>rs3-in</sup> animals contain a small population of
GFP+ nematocytes and gland cells in addition to GFP+ neurons. We plotted
known nematocyte and gland markers identified in Siebert 2019 and all
four 10X libraries despite the expectation that no gland/nemato cells
should be present in pan-neuronal (PN) library derived from
Tg(tba1c:mNeonGreen)<sup>cj1-g</sup>. Non-neuronal cell types were
removed from each library for downstream integration and clustering.
<br></p>
<p>Seurat objects were renamed at this point:<br> -nGreen_budding1 is
now <strong>budding1</strong><br> -nGreen_budding2 is now
<strong>budding2</strong><br> -nGreen is now <strong>nG</strong><br>
-Pan-neuro is now <strong>PN</strong><br></p>
<p><strong>Removal of non-neuronal cells from neuronGreen (nG)
library</strong><br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># Initial clustering nGreen non-budding + removing clusters cl 15, 18, 21 ---------------------------------------
# Because the nGreen transgenic line contains a small population of transgenic nematocytes and gland cells in addition to neurons, we performed a basic cluster analysis of the three libraries collected using Tg(actin1:GFP)rs3-in/nGreen animals. After clustering, expression plots of nematocyte and gland cell molecular markers (identified in (Siebert et al., 2019)) were generated and any clusters expressing those markers were removed.

nG &lt;- NormalizeData(nG, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000)

nG &lt;- FindVariableFeatures(nG, selection.method = &quot;vst&quot;, verbose = TRUE)

all.genes &lt;- rownames(nG)
nG &lt;- ScaleData(nG, features = all.genes)

nG &lt;- RunPCA(nG, features = VariableFeatures(object = nG))
ElbowPlot(nG)
nG &lt;- FindNeighbors(nG, dims = 1:10)
nG &lt;- FindClusters(nG, recution.type = &quot;pca&quot;, dims.use = 1:10, resolution = 0.9)
nG &lt;- RunUMAP(nG, dims = 1:10)

# Progenitor and neuron markers 
p1 &lt;- DimPlot(nG, reduction = &quot;umap&quot;, label = TRUE) + NoLegend()
p2 &lt;- FeaturePlot(nG, &quot;G002332&quot;, label = F) # HyIcell
p3 &lt;- FeaturePlot(nG, &quot;G004515&quot;, label = F) # elav2 - all neural cell types
p4 &lt;- FeaturePlot(nG, &quot;G019559&quot;, label = F) # tba1c - differentiated neurons
grid.arrange(p1, p2, p3, p4, ncol=2)</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/nG_neurons.png"
alt="Neuro/Prog: nG" />
<div class="figcaption">Neuro/Prog: nG</div>
</div>
<pre class="r"><code># Nemato Clusters 
p1 &lt;- DimPlot(nG, reduction = &quot;umap&quot;, label = TRUE) + NoLegend()
p2 &lt;- FeaturePlot(nG, &quot;G023536&quot;, label = F)
p3 &lt;- FeaturePlot(nG, &quot;G021814&quot;, label = F)
p4 &lt;- FeaturePlot(nG, &quot;G028500&quot;, label = F)
p5 &lt;- FeaturePlot(nG, &quot;G006709&quot;, label = F)
p6 &lt;- FeaturePlot(nG, &quot;G005522&quot;, label = F)
p7 &lt;- FeaturePlot(nG, &quot;G012451&quot;, label = F)
p8 &lt;- FeaturePlot(nG, &quot;G008423&quot;, label = F)
p9 &lt;- FeaturePlot(nG, &quot;G016939&quot;, label = F)
p10 &lt;- FeaturePlot(nG, &quot;G007115&quot;, label = F)
p11 &lt;- FeaturePlot(nG, &quot;G019581&quot;, label = F)
p12 &lt;- FeaturePlot(nG, &quot;G014365&quot;, label = F)
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, ncol=3,top=&quot;Nematocytes/Nematoblasts&quot;)
grid.arrange(p1, p12, ncol=2,top=&quot;Nematocytes/Nematoblasts&quot;)</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/nG_nemato.png"
alt="Nemato: nG" />
<div class="figcaption">Nemato: nG</div>
</div>
<pre class="r"><code># Gland Cluster 
p1 &lt;- DimPlot(nG, reduction = &quot;umap&quot;, label = TRUE) + NoLegend()
p2 &lt;- FeaturePlot(nG, &quot;G020297&quot;, label = F)
p3 &lt;- FeaturePlot(nG, &quot;G020296&quot;, label = F)
p4 &lt;- FeaturePlot(nG, &quot;G027769&quot;, label = F)
p5 &lt;- FeaturePlot(nG, &quot;G015498&quot;, label = F)
p6 &lt;- FeaturePlot(nG, &quot;G025358&quot;, label = F)
p7 &lt;- FeaturePlot(nG, &quot;G001965&quot;, label = F)
p8 &lt;- FeaturePlot(nG, &quot;G002583&quot;, label = F)
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, ncol=2,top=&quot;Gland Cells&quot;)</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/nG_gland.png"
alt="Gland: nG" /> nG clusters 15 and 21 express known nematocyte
markers and nG cluster 18 expresses gland cell markers and no neuronal
markers. We removed cells from clusters 15, 18, and 21 for downstream
data integration.<br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># subset out 15, 18, 21
levels(nG)
clusters_to_subset_nG &lt;- c(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;16&quot;, &quot;17&quot;, &quot;19&quot;, &quot;20&quot;)

nG_sub &lt;- subset(nG, idents = clusters_to_subset_nG)
levels(nG_sub)
DimPlot(nG_sub, reduction = &quot;umap&quot;, label = TRUE) + NoLegend()</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/nG_sub.png"
alt="Final: nG" /> <strong>Removal of non-neuronal cells from
neuronGreen budding1 (budding1) library</strong><br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># Initial clustering Budding1 + removing clusters 21, 22, 24, 27 ---------------------------------------
budding1 &lt;- NormalizeData(budding1, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000)

budding1 &lt;- FindVariableFeatures(budding1, selection.method = &quot;vst&quot;, verbose = TRUE)

all.genes &lt;- rownames(budding1)
budding1 &lt;- ScaleData(budding1, features = all.genes)

budding1 &lt;- RunPCA(budding1, features = VariableFeatures(object = budding1))
ElbowPlot(budding1)
budding1 &lt;- FindNeighbors(budding1, dims = 1:12)
budding1 &lt;- FindClusters(budding1, recution.type = &quot;pca&quot;, dims.use = 1:12, resolution = 1.3)
budding1 &lt;- RunUMAP(budding1, dims = 1:12)

# Progenitor and neuron markers 
p1 &lt;- DimPlot(budding1, reduction = &quot;umap&quot;, label = TRUE, repel = T) + NoLegend()
p2 &lt;- FeaturePlot(budding1, &quot;G002332&quot;, label = F) # HyIcell
p3 &lt;- FeaturePlot(budding1, &quot;G004515&quot;, label = F) # elav2 - all neural cell types
p4 &lt;- FeaturePlot(budding1, &quot;G019559&quot;, label = F) # tba1c - differentiated neurons
grid.arrange(p1, p2, p3, p4, ncol=2)</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/budding1_neurons.png"
alt="Neuro/Prog: Budding1" />
<div class="figcaption">Neuro/Prog: Budding1</div>
</div>
<pre class="r"><code># Nemato Clusters
p1 &lt;- DimPlot(budding1, reduction = &quot;umap&quot;, label = TRUE, repel = T) + NoLegend()
p2 &lt;- FeaturePlot(budding1, &quot;G023536&quot;, label = F)
p3 &lt;- FeaturePlot(budding1, &quot;G021814&quot;, label = F)
p4 &lt;- FeaturePlot(budding1, &quot;G028500&quot;, label = F)
p5 &lt;- FeaturePlot(budding1, &quot;G006709&quot;, label = F)
p6 &lt;- FeaturePlot(budding1, &quot;G005522&quot;, label = F)
p7 &lt;- FeaturePlot(budding1, &quot;G012451&quot;, label = F)
p8 &lt;- FeaturePlot(budding1, &quot;G008423&quot;, label = F)
p9 &lt;- FeaturePlot(budding1, &quot;G016939&quot;, label = F)
p10 &lt;- FeaturePlot(budding1, &quot;G007115&quot;, label = F)
p11 &lt;- FeaturePlot(budding1, &quot;G019581&quot;, label = F)
p12 &lt;- FeaturePlot(budding1, &quot;G014365&quot;, label = F)
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, ncol=3,top=&quot;Nematocytes/Nematoblasts&quot;)</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/budding1_nemato.png"
alt="Nemato: Budding1" />
<div class="figcaption">Nemato: Budding1</div>
</div>
<pre class="r"><code># Gland Cluster
p1 &lt;- DimPlot(budding1, reduction = &quot;umap&quot;, label = TRUE, repel = T) + NoLegend()
p5 &lt;- FeaturePlot(budding1, &quot;G015498&quot;, label = F)
p6 &lt;- FeaturePlot(budding1, &quot;G025358&quot;, label = F)
p7 &lt;- FeaturePlot(budding1, &quot;G001965&quot;, label = F)
p8 &lt;- FeaturePlot(budding1, &quot;G002583&quot;, label = F)
grid.arrange(p1, p5, p6, p7, p8, ncol=3,top=&quot;Gland Cells&quot;)</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/budding1_gland.png"
alt="Gland: Budding1" /> To further investigate cluster 22 (126 cells)
we found molecular markers for the cluster using the
<code>Seurat::FindMarkers</code> function to identify markers with
positive expression in at least 25% of cells in that cluster. We plotted
the top 5 markers on the whole <em>Hydra</em> Seurat object which can be
downloaded <a
href="https://research.nhgri.nih.gov/HydraAEP/download/scriptsdata/05_hydraAtlasReMap.tar.gz">here</a>).
The expression patterns of the top 5 cluster 22 molecular markers are
ubiquitously expressed in the whole <em>Hydra</em> dataset including the
epithelial cells. The genes contributing to the clustering of cluster 22
are likely representative of stress (supported by evidence of a
mitochondrial gene (MT-16S) as one of the top markers for the cluster).
Therefore, we removed the cells in cluster 22 from the budding1 Seurat
object for downstream analysis. <br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># Find and plot markers for cluster budding1 cluster 22 on whole animal data (Siebert 2019, Cazet 2023)
cluster22.markers &lt;- FindMarkers(budding1, ident.1 = 22, min.pct = 0.25, only.pos = TRUE)
genes &lt;- row.names(head(cluster22.markers, 6)) #MT-16S not found in whole animal data. Remove from list, but note it is a mito marker
genes &lt;- genes[c(1,2,4,5,6)]

# load whole animal dataset (availbale for download here: https://research.nhgri.nih.gov/HydraAEP/download/scriptsdata/05_hydraAtlasReMap.tar.gz)
whole.animal &lt;- readRDS(&quot;../../../../scPortal/makeShinyMulti/data/nonDubDsLabeledAllMeta-2.rds&quot;)
DefaultAssay(whole.animal) &lt;- &quot;SCT&quot;

p1 &lt;- DimPlot(whole.animal, label = F) + NoLegend() 
p2 &lt;- FeaturePlot(whole.animal, genes[1], order = T, label = F) + NoLegend()
p3 &lt;- FeaturePlot(whole.animal, genes[2], order = T, label = F) + NoLegend()
p4 &lt;- FeaturePlot(whole.animal, genes[3], order = T, label = F) + NoLegend()
p5 &lt;- FeaturePlot(whole.animal, genes[4], order = T, label = F) + NoLegend()
p6 &lt;- FeaturePlot(whole.animal, genes[5], order = T, label = F) + NoLegend()
grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3,top=&quot;budding1 cluster 22 Markers&quot;)</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/budding1_cl22.markers.png"
alt="Budding1: Cluster 22 Markers" /> Budding1 clusters 21 and 24
express known nematocyte markers and cluster 27 expresses gland cell
markers and no neuronal markers. We removed cells from clusters 21, 24,
27 as well as cluster 22 (which primarily expresses stress gene markers)
for downstream data integration.<br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># subset out 21, 22, 24, 27
levels(budding1)
clusters_to_subset_bud1 &lt;- c(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;,  &quot;3&quot;,  &quot;4&quot;,  &quot;5&quot;,  &quot;6&quot;,  &quot;7&quot;,  &quot;8&quot;, &quot;9&quot;,  &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, &quot;19&quot;, &quot;20&quot;, &quot;23&quot;, &quot;25&quot;, &quot;26&quot;, &quot;28&quot;)

budding1_sub &lt;- subset(budding1, idents = clusters_to_subset_bud1)
levels(budding1_sub)
DimPlot(budding1_sub, reduction = &quot;umap&quot;, label = TRUE, repel = T) + NoLegend()</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/budding1_sub.png"
alt="Final: Budding1" /> <strong>Removal of non-neuronal cells from
neuronGreen budding2 (budding2) library</strong><br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># Initial clustering Budding2 + removing clusters cl 21, 25, 26, 28, 29 -------------------------------
budding2 &lt;- NormalizeData(budding2, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000)

budding2 &lt;- FindVariableFeatures(budding2, selection.method = &quot;vst&quot;, verbose = TRUE)

all.genes &lt;- rownames(budding2)
budding2 &lt;- ScaleData(budding2, features = all.genes)

budding2 &lt;- RunPCA(budding2, features = VariableFeatures(object = budding2))
ElbowPlot(budding2)
budding2 &lt;- FindNeighbors(budding2, dims = 1:15)
budding2 &lt;- FindClusters(budding2, recution.type = &quot;pca&quot;, dims.use = 1:15, resolution = 1.3)
budding2 &lt;- RunUMAP(budding2, dims = 1:15)

# Progenitor and neuron markers
p1 &lt;- DimPlot(budding2, reduction = &quot;umap&quot;, label = TRUE, repel = T) + NoLegend()
p2 &lt;- FeaturePlot(budding2, &quot;G002332&quot;, label = F) # HyIcell
p3 &lt;- FeaturePlot(budding2, &quot;G004515&quot;, label = F) # elav2 - all neural cell types
p4 &lt;- FeaturePlot(budding2, &quot;G019559&quot;, label = F) # tba1c - differentiated neurons
grid.arrange(p1, p2, p3, p4, ncol=2)</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/budding2_neurons.png"
alt="Neuro/Prog: Budding2" />
<div class="figcaption">Neuro/Prog: Budding2</div>
</div>
<pre class="r"><code># Nemato Clusters 
p1 &lt;- DimPlot(budding2, reduction = &quot;umap&quot;, label = TRUE, repel = T) + NoLegend()
p2 &lt;- FeaturePlot(budding2, &quot;G023536&quot;, label = F)
p3 &lt;- FeaturePlot(budding2, &quot;G021814&quot;, label = F)
p4 &lt;- FeaturePlot(budding2, &quot;G028500&quot;, label = F)
p5 &lt;- FeaturePlot(budding2, &quot;G006709&quot;, label = F)
p6 &lt;- FeaturePlot(budding2, &quot;G005522&quot;, label = F)
p7 &lt;- FeaturePlot(budding2, &quot;G012451&quot;, label = F)
p8 &lt;- FeaturePlot(budding2, &quot;G008423&quot;, label = F)
p9 &lt;- FeaturePlot(budding2, &quot;G016939&quot;, label = F)
p10 &lt;- FeaturePlot(budding2, &quot;G007115&quot;, label = F)
p11 &lt;- FeaturePlot(budding2, &quot;G019581&quot;, label = F)
p12 &lt;- FeaturePlot(budding2, &quot;G014365&quot;, label = F)
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, ncol=3,top=&quot;Nematocytes/Nematoblasts&quot;)</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/budding2_nemato.png"
alt="Nemato: Budding2" />
<div class="figcaption">Nemato: Budding2</div>
</div>
<pre class="r"><code># Gland Cluster
p1 &lt;- DimPlot(budding2, reduction = &quot;umap&quot;, label = TRUE, repel = T) + NoLegend()
p5 &lt;- FeaturePlot(budding2, &quot;G015498&quot;, label = F)
p6 &lt;- FeaturePlot(budding2, &quot;G025358&quot;, label = F)
p7 &lt;- FeaturePlot(budding2, &quot;G001965&quot;, label = F)
p8 &lt;- FeaturePlot(budding2, &quot;G002583&quot;, label = F)
grid.arrange(p1, p5, p6, p7, p8, ncol=3,top=&quot;Gland Cells&quot;)</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/budding2_gland.png"
alt="Gland: Budding2" /> To further investigate cluster 25 (89 cells) we
found molecular markers for the cluster using the
<code>Seurat::FindMarkers</code> function to identify markers with
positive expression in at least 25% of cells in that cluster. We found
evidence of stress genes (G014159, G027286, MT-16S) among the top
markers for cluster 25 and chose to remove the cluster from the seurat
object for donwstream analysis. <br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># stress cluster 25
cluster25.markers &lt;- FindMarkers(budding2, ident.1 = 25, min.pct = 0.25, only.pos = TRUE)
head(cluster25.markers,10)</code></pre>
<p>We found a small cluster (30) of 22 cells in the budding2 library. we
found molecular markers for the cluster using the
<code>Seurat::FindMarkers</code> function to identify markers with
positive expression in at least 25% of cells in that cluster. We did not
find evidence of previously identified stress markers in cluster 30 so
we plotted the top 5 markers on the whole <em>Hydra</em> dataset. The
expression patterns of the top 5 cluster 30 molecular markers are
primarily epithelial in the whole <em>Hydra</em> dataset. We removed
cluster 30 from the dataset for downstream analysis.<br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># cluster 30 (22 cells)
cluster30.markers &lt;- FindMarkers(budding2, ident.1 = 30, min.pct = 0.25, only.pos = TRUE)
genes &lt;- row.names(head(cluster30.markers, 10)) #Top clusters are not identified stress markers. Plot top 5

# Plot cluster 30 markers on whole hydra dataset (loaded above)
p1 &lt;- DimPlot(whole.animal, label = F) + NoLegend() 
p2 &lt;- FeaturePlot(whole.animal, genes[1], order = T, label = F) + NoLegend()
p3 &lt;- FeaturePlot(whole.animal, genes[2], order = T, label = F) + NoLegend()
p4 &lt;- FeaturePlot(whole.animal, genes[3], order = T, label = F) + NoLegend()
p5 &lt;- FeaturePlot(whole.animal, genes[4], order = T, label = F) + NoLegend()
p6 &lt;- FeaturePlot(whole.animal, genes[5], order = T, label = F) + NoLegend()
grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3,top=&quot;budding1 cluster 30 Markers&quot;)
# Top markers for cluster 30 are STRONGLY epithelial, not neuronal. Remove from dataset.</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/budding2_cl.30.markers.png"
alt="Budding2: Cluster 30 Markers" />
<div class="figcaption">Budding2: Cluster 30 Markers</div>
</div>
<p>Budding2 clusters 21, 28, and 29 express known nematocyte markers and
cluster 26 expresses gland cell markers and no neuronal markers. We
removed cells from clusters 21, 26, 28, 29 as well as cluster 25
(primarily expresses stress gene markers) and cluster (primarily
expressing epithelial markers) for downstream data integration.<br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># subset out 21, 25, 26, 28, 29
levels(budding2)
clusters_to_subset_bud2 &lt;- c(&quot;0&quot;, &quot;1&quot;,  &quot;2&quot;,  &quot;3&quot;,  &quot;4&quot;,  &quot;5&quot;,  &quot;6&quot;,  &quot;7&quot;,  &quot;8&quot;,  &quot;9&quot;,  &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, &quot;19&quot;, &quot;20&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;27&quot;)

budding2_sub &lt;- subset(budding2, idents = clusters_to_subset_bud2)
levels(budding2_sub)
DimPlot(budding2_sub, reduction = &quot;umap&quot;, label = TRUE, repel = T) + NoLegend()</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/budding2_sub.png"
alt="Final: Budding2" /> <strong>Removal of non-neuronal cells from
Pan-Neuronal (PN) library</strong><br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># Initial clustering PN, no gland/nemato cells in this library ---------------------------------------
PN &lt;- NormalizeData(PN, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000)

PN &lt;- FindVariableFeatures(PN, selection.method = &quot;vst&quot;, verbose = TRUE)

all.genes &lt;- rownames(PN)
PN &lt;- ScaleData(PN, features = all.genes)

PN &lt;- RunPCA(PN, features = VariableFeatures(object = PN))
ElbowPlot(PN)
PN &lt;- FindNeighbors(PN, dims = 1:16)
PN &lt;- FindClusters(PN, recution.type = &quot;pca&quot;, dims.use = 1:16, resolution = 0.9)
PN &lt;- RunUMAP(PN, dims = 1:16)

# Progenitor and neuron markers
p1 &lt;- DimPlot(PN, reduction = &quot;umap&quot;, label = TRUE, repel = T) + NoLegend()
p2 &lt;- FeaturePlot(PN, &quot;G002332&quot;, label = F) # HyIcell
p3 &lt;- FeaturePlot(PN, &quot;G004515&quot;, label = F) # elav2 - all neural cell types
p4 &lt;- FeaturePlot(PN, &quot;G019559&quot;, label = F) # tba1c - differentiated neurons
grid.arrange(p1, p2, p3, p4, ncol=2)</code></pre>
<div class="float">
<img src="resources/01_HydraNeuronAtlas/seurat/single.libs/PN_neuro.png"
alt="Neuro/Prog: PN" />
<div class="figcaption">Neuro/Prog: PN</div>
</div>
<pre class="r"><code># Nemato Clusters 
p1 &lt;- DimPlot(PN, reduction = &quot;umap&quot;, label = TRUE, repel = T) + NoLegend()
p2 &lt;- FeaturePlot(PN, &quot;G023536&quot;, label = F)
p3 &lt;- FeaturePlot(PN, &quot;G021814&quot;, label = F)
p4 &lt;- FeaturePlot(PN, &quot;G028500&quot;, label = F)
p5 &lt;- FeaturePlot(PN, &quot;G006709&quot;, label = F)
p6 &lt;- FeaturePlot(PN, &quot;G005522&quot;, label = F)
p7 &lt;- FeaturePlot(PN, &quot;G012451&quot;, label = F)
p8 &lt;- FeaturePlot(PN, &quot;G008423&quot;, label = F)
p9 &lt;- FeaturePlot(PN, &quot;G016939&quot;, label = F)
p10 &lt;- FeaturePlot(PN, &quot;G007115&quot;, label = F)
p11 &lt;- FeaturePlot(PN, &quot;G019581&quot;, label = F)
p12 &lt;- FeaturePlot(PN, &quot;G014365&quot;, label = F)
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, ncol=3,top=&quot;Nematocytes/Nematoblasts&quot;)
grid.arrange(p1, p12, ncol=2,top=&quot;Nematocytes/Nematoblasts&quot;)</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/PN_nemato.png"
alt="Nemato: PN" />
<div class="figcaption">Nemato: PN</div>
</div>
<pre class="r"><code># Gland Cluster 
p1 &lt;- DimPlot(PN, reduction = &quot;umap&quot;, label = TRUE, repel = T) + NoLegend()
p2 &lt;- FeaturePlot(PN, &quot;G020297&quot;, label = F)
p3 &lt;- FeaturePlot(PN, &quot;G020296&quot;, label = F)
p4 &lt;- FeaturePlot(PN, &quot;G027769&quot;, label = F)
p5 &lt;- FeaturePlot(PN, &quot;G015498&quot;, label = F)
p6 &lt;- FeaturePlot(PN, &quot;G025358&quot;, label = F)
p7 &lt;- FeaturePlot(PN, &quot;G001965&quot;, label = F)
p8 &lt;- FeaturePlot(PN, &quot;G002583&quot;, label = F)
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, ncol=2,top=&quot;Gland Cells&quot;)</code></pre>
<div class="float">
<img src="resources/01_HydraNeuronAtlas/seurat/single.libs/PN_gland.png"
alt="Gland: PN" />
<div class="figcaption">Gland: PN</div>
</div>
<pre class="r"><code># PN labeled UMAP
DimPlot(PN, reduction = &quot;umap&quot;, label = TRUE) + NoLegend()</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/PN_final.png"
alt="Final: PN" /> <strong>Removal of non-neuronal cells from Drop-seq
Neuron (ds.neuro) library</strong><br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># Initial clustering ds.neuro, no gland/nemato cells in this library ---------------------------------------

ds.neuro &lt;- NormalizeData(ds.neuro, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000)

ds.neuro &lt;- FindVariableFeatures(ds.neuro, selection.method = &quot;vst&quot;, verbose = TRUE)

all.genes &lt;- rownames(ds.neuro)
ds.neuro &lt;- ScaleData(ds.neuro, features = all.genes)

ds.neuro &lt;- RunPCA(ds.neuro, features = VariableFeatures(object = ds.neuro))
ElbowPlot(ds.neuro)
ds.neuro &lt;- FindNeighbors(ds.neuro, dims = 1:10)
ds.neuro &lt;- FindClusters(ds.neuro, recution.type = &quot;pca&quot;, dims.use = 1:10, resolution = 0.9)
ds.neuro &lt;- RunUMAP(ds.neuro, dims = 1:10)

# Progenitor and neuron markers = budding2_neurons 600x500
p1 &lt;- DimPlot(ds.neuro, reduction = &quot;umap&quot;, label = TRUE, repel = T) + NoLegend()
p2 &lt;- FeaturePlot(ds.neuro, &quot;G002332&quot;, label = F) # HyIcell
p3 &lt;- FeaturePlot(ds.neuro, &quot;G004515&quot;, label = F) # elav2 - all neural cell types
p4 &lt;- FeaturePlot(ds.neuro, &quot;G019559&quot;, label = F) # tba1c - differentiated neurons
grid.arrange(p1, p2, p3, p4, ncol=2)</code></pre>
<div class="float">
<img src="resources/01_HydraNeuronAtlas/seurat/single.libs/ds_neuro.png"
alt="Neuro/Prog: DropSeq" />
<div class="figcaption">Neuro/Prog: DropSeq</div>
</div>
<pre class="r"><code># Nemato Clusters
p1 &lt;- DimPlot(ds.neuro, reduction = &quot;umap&quot;, label = TRUE, repel = T) + NoLegend()
p2 &lt;- FeaturePlot(ds.neuro, &quot;G023536&quot;, label = F)
p3 &lt;- FeaturePlot(ds.neuro, &quot;G021814&quot;, label = F)
p4 &lt;- FeaturePlot(ds.neuro, &quot;G028500&quot;, label = F)
p5 &lt;- FeaturePlot(ds.neuro, &quot;G006709&quot;, label = F)
p6 &lt;- FeaturePlot(ds.neuro, &quot;G005522&quot;, label = F)
p7 &lt;- FeaturePlot(ds.neuro, &quot;G012451&quot;, label = F)
p8 &lt;- FeaturePlot(ds.neuro, &quot;G008423&quot;, label = F)
p9 &lt;- FeaturePlot(ds.neuro, &quot;G016939&quot;, label = F)
p10 &lt;- FeaturePlot(ds.neuro, &quot;G007115&quot;, label = F)
p11 &lt;- FeaturePlot(ds.neuro, &quot;G019581&quot;, label = F)
p12 &lt;- FeaturePlot(ds.neuro, &quot;G014365&quot;, label = F)
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, ncol=3,top=&quot;Nematocytes/Nematoblasts&quot;)
grid.arrange(p1, p12, ncol=2,top=&quot;Nematocytes/Nematoblasts&quot;)</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/single.libs/ds_nemato.png"
alt="Nemato: DropSeq" />
<div class="figcaption">Nemato: DropSeq</div>
</div>
<pre class="r"><code># Gland Cluster 
p1 &lt;- DimPlot(ds.neuro, reduction = &quot;umap&quot;, label = TRUE, repel = T) + NoLegend()
p2 &lt;- FeaturePlot(ds.neuro, &quot;G020297&quot;, label = F)
p3 &lt;- FeaturePlot(ds.neuro, &quot;G020296&quot;, label = T)
p4 &lt;- FeaturePlot(ds.neuro, &quot;G027769&quot;, label = T)
p5 &lt;- FeaturePlot(ds.neuro, &quot;G015498&quot;, label = T)
p6 &lt;- FeaturePlot(ds.neuro, &quot;G025358&quot;, label = T)
p7 &lt;- FeaturePlot(ds.neuro, &quot;G001965&quot;, label = F)
p8 &lt;- FeaturePlot(ds.neuro, &quot;G002583&quot;, label = F)
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, ncol=2,top=&quot;Gland Cells&quot;)</code></pre>
<div class="float">
<img src="resources/01_HydraNeuronAtlas/seurat/single.libs/ds_gland.png"
alt="Gland: DropSeq" />
<div class="figcaption">Gland: DropSeq</div>
</div>
<pre class="r"><code>DimPlot(ds.neuro, reduction = &quot;umap&quot;, label = TRUE, repel = T) + NoLegend()</code></pre>
<div class="float">
<img src="resources/01_HydraNeuronAtlas/seurat/single.libs/ds_final.png"
alt="Final: DropSeq" />
<div class="figcaption">Final: DropSeq</div>
</div>
<p>Cell IDs and count data were extracted from the subsetted nGreen
nonbudding (nG), budding 1, and budding 2 data and used to create new
Seurat objects for nGreen, budding1, and budding2 for downstream
analysis. Pan Neuronal (PN) and Drop-seq neuro (ds.neuro) Seurat objects
remain the same.<br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># Extract cell IDs and make new objects with the &quot;cleaned&quot; data from the nGreen objects -------------------------------------------------

# To extract the cell IDS from object@raw.data, use GetAssayData(object = object, slot = &quot;counts&quot;)

budding1_clean &lt;- GetAssayData(object = budding1_sub, slot = &quot;counts&quot;)
budding2_clean &lt;- GetAssayData(object = budding2_sub, slot = &quot;counts&quot;)
nG_clean &lt;- GetAssayData(object = nG_sub, slot = &quot;counts&quot;)

# Make new Seurat objects using the extracted cell IDs

# Budding 1 library

# Create Seurat object with the raw counts, keeping all genes expressed in 3 or more cells and all cells with 200 or more transcripts 
budding1_clean_seur &lt;- CreateSeuratObject(counts = budding1_clean, project = &quot;budding1&quot;, min.cells = 3, min.features = 200)

# Calculate percentage of mitochondrial reads per cell and add data to Suerat object
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
budding1_clean_seur[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(budding1_clean_seur, pattern = &quot;^MT-&quot;)


# Budding 2 library

# Create Seurat object with the raw counts, keeping all genes expressed in 3 or more cells and all cells with 200 or more transcripts
budding2_clean_seur &lt;- CreateSeuratObject(counts = budding2_clean, project = &quot;budding2&quot;, min.cells = 3, min.features = 200)

# Calculate percentage of mitochondrial reads per cell and add data to Suerat object
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
budding2_clean_seur[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(budding2_clean_seur, pattern = &quot;^MT-&quot;)


# Non-budding library

# Create Seurat object with the raw counts, keeping all genes expressed in 3 or more cells and all cells with 200 or more transcripts
nG_clean_seur &lt;- CreateSeuratObject(counts = nG_clean, project = &quot;neonGreen&quot;, min.cells = 3, min.features = 200, )

# Calculate percentage of mitochondrial reads per cell and add data to Suerat object
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
nG_clean_seur[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(nG_clean_seur, pattern = &quot;^MT-&quot;)</code></pre>
<!-- headings -->
<a id="item-three"></a>
<h3>
Initial Integration and Clustering
</h3>
<p>After removing low quality and non-neuronal cells, we integrated
these separate Seurat objects using the SCT Integration workflow
following SCTransform normalization.<br></p>
<p>Because the data collected from Siebert 2019 originated from 14
libraries and was input as a single matrix, we first extracted cells
from each library from the aggregated object. We generated individual
Seurat objects for each of individual Dorp-seq library and added batch
information matching the original Siebert 2019 study prefixed with
“ds.”. We decided to remove drop-seq library ds.06_FM_S1 as it gave
errors during preliminary integration. This could perhaps be due to the
too few number of cells (contained 68 cells) within the library.<br></p>
<p>Before normalization, we added a stress module score to each library
after identifying genes that seem to be associated with 1) batch effects
and 2) stress (e.g. MT-16S, G014159, G027286, G015960, G010241, G009485,
G001468, G022617, G021648).<br></p>
<p>nG and budding Seurat objects were renamed at this point:<br> -nG is
now <strong>nGreen</strong><br> -budding1 is now
<strong>nGreen_budding1</strong><br> -budding2 is now
<strong>nGreen_budding2</strong><br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)
<!-- Don't run this code. Use images provided by Abby --></p>
<pre class="r"><code># INITIAL DATA INTEGRATION, PCA, AND CLUSTER ANALYSIS ---------------------

# Add in module scores for stress and mitochondrial genes ----------------------------------------------------

# I performed some preliminary cluster analysis and identified a few genes that seem to be associated with 1) batch effects and 2) stress. Thus, I will generate module scores (using the AddModuleScore function in Seurat) for all cells based on this gene set and use these scores to the vars.to.regress argument in SCT transform

stress_genes_list &lt;- list(c(&quot;MT-16S&quot;,
                            &quot;G014159&quot;,
                            &quot;G027286&quot;,
                            &quot;G015960&quot;,
                            &quot;G010241&quot;,
                            &quot;G009485&quot;,
                            &quot;G001468&quot;,
                            &quot;G022617&quot;,
                            &quot;G021648&quot;))

nGreen_budding1 &lt;- AddModuleScore(
  object = nGreen_budding1,
  features = stress_genes_list,
  name = &quot;Stress_genes&quot;
)

nGreen_budding2 &lt;- AddModuleScore(
  object = nGreen_budding2,
  features = stress_genes_list,
  name = &quot;Stress_genes&quot;
)

nGreen &lt;- AddModuleScore(
  object = nGreen,
  features = stress_genes_list,
  name = &quot;Stress_genes&quot;
)

PN &lt;- AddModuleScore(
  object = PN,
  features = stress_genes_list,
  name = &quot;Stress_genes&quot;
)

ds.neuro &lt;- AddModuleScore(
  object = ds.neuro,
  features = stress_genes_list,
  name = &quot;Stress_genes&quot;
)


# Assign batch identities to cells from each library -----------------------------

# Next, we want to assign batch identities to cells from each library so we can look for batch effects and integrate all of the libraries together. We split the larger drop-seq data set into the original 15 libraries. Through preliminary cluster analysis, we also decided to remove drop-seq library D06_FM_S1 (contained 68 cells), because it was giving errors during integration. This could perhaps be due to the too few number of cells within the library

# Because data for each drop-seq library are combined into one matrix, we need to extract cells from each libary and put them into their own objects. 

# Here, we are subsetting cells from each drop-seq library from the larger drop-seq matrix into their own objects
dsp1 &lt;- rownames(ds.neuro@meta.data)[ds.neuro@meta.data[,&quot;orig.ident&quot;] == &quot;D01_D1_S1&quot;]
dsp2 &lt;- rownames(ds.neuro@meta.data)[ds.neuro@meta.data[,&quot;orig.ident&quot;] == &quot;D01_P2_S4&quot;]
dsp3 &lt;- rownames(ds.neuro@meta.data)[ds.neuro@meta.data[,&quot;orig.ident&quot;] == &quot;D02_CO_S2&quot;]
dsp4 &lt;- rownames(ds.neuro@meta.data)[ds.neuro@meta.data[,&quot;orig.ident&quot;] == &quot;D02_P1_S3&quot;]
dsp5 &lt;- rownames(ds.neuro@meta.data)[ds.neuro@meta.data[,&quot;orig.ident&quot;] == &quot;D02_PB_S4&quot;]
dsp6 &lt;- rownames(ds.neuro@meta.data)[ds.neuro@meta.data[,&quot;orig.ident&quot;] == &quot;D03_KI_S1&quot;]
dsp7 &lt;- rownames(ds.neuro@meta.data)[ds.neuro@meta.data[,&quot;orig.ident&quot;] == &quot;D03_MA_S2&quot;]
dsp8 &lt;- rownames(ds.neuro@meta.data)[ds.neuro@meta.data[,&quot;orig.ident&quot;] == &quot;D03_FM_S3&quot;]
dsp9 &lt;- rownames(ds.neuro@meta.data)[ds.neuro@meta.data[,&quot;orig.ident&quot;] == &quot;D06_FM_S1&quot;]
dsp10 &lt;- rownames(ds.neuro@meta.data)[ds.neuro@meta.data[,&quot;orig.ident&quot;] == &quot;D06_MA_S3&quot;]
dsp11 &lt;- rownames(ds.neuro@meta.data)[ds.neuro@meta.data[,&quot;orig.ident&quot;] == &quot;D06_KI_S4&quot;]
dsp12 &lt;- rownames(ds.neuro@meta.data)[ds.neuro@meta.data[,&quot;orig.ident&quot;] == &quot;D11_PO_S1&quot;]
dsp13 &lt;- rownames(ds.neuro@meta.data)[ds.neuro@meta.data[,&quot;orig.ident&quot;] == &quot;D11_BU_S2&quot;]
dsp14 &lt;- rownames(ds.neuro@meta.data)[ds.neuro@meta.data[,&quot;orig.ident&quot;] == &quot;D12_N1_S1&quot;]
dsp15 &lt;- rownames(ds.neuro@meta.data)[ds.neuro@meta.data[,&quot;orig.ident&quot;] == &quot;D12_N2_S2&quot;]

D01_D1_S1 &lt;- subset(ds.neuro, cells = dsp1)
D01_D1_S1@meta.data$batch &lt;- &quot;ds.01_D1&quot;

D01_P2_S4 &lt;- subset(ds.neuro, cells = dsp2)
D01_P2_S4@meta.data$batch &lt;- &quot;ds.01_P2&quot;

D02_CO_S2 &lt;- subset(ds.neuro, cells = dsp3)
D02_CO_S2@meta.data$batch &lt;- &quot;ds.02_CO&quot;

D02_P1_S3 &lt;- subset(ds.neuro, cells = dsp4)
D02_P1_S3@meta.data$batch &lt;- &quot;ds.02_P1&quot;

D02_PB_S4 &lt;- subset(ds.neuro, cells = dsp5)
D02_PB_S4@meta.data$batch &lt;- &quot;ds.02_PB&quot;

D03_KI_S1 &lt;- subset(ds.neuro, cells = dsp6)
D03_KI_S1@meta.data$batch &lt;- &quot;ds.03_KI&quot;

D03_MA_S2 &lt;- subset(ds.neuro, cells = dsp7)
D03_MA_S2@meta.data$batch &lt;- &quot;ds.03_MA&quot;

D03_FM_S3 &lt;- subset(ds.neuro, cells = dsp8)
D03_FM_S3@meta.data$batch &lt;- &quot;ds.03_FM&quot;

D06_FM_S1 &lt;- subset(ds.neuro, cells = dsp9)
D06_FM_S1@meta.data$batch &lt;- &quot;ds.06_FM&quot;

D06_MA_S3 &lt;- subset(ds.neuro, cells = dsp10)
D06_MA_S3@meta.data$batch &lt;- &quot;ds.06_MA&quot;

D06_KI_S4 &lt;- subset(ds.neuro, cells = dsp11)
D06_KI_S4@meta.data$batch &lt;- &quot;ds.06_KI&quot;

D11_PO_S1 &lt;- subset(ds.neuro, cells = dsp12)
D11_PO_S1@meta.data$batch &lt;- &quot;ds.11_PO&quot;

D11_BU_S2 &lt;- subset(ds.neuro, cells = dsp13)
D11_BU_S2@meta.data$batch &lt;- &quot;ds.11_BU&quot;

D12_N1_S1 &lt;- subset(ds.neuro, cells = dsp14)
D12_N1_S1@meta.data$batch &lt;- &quot;ds.12_N1&quot;

D12_N2_S2 &lt;- subset(ds.neuro, cells = dsp15)
D12_N2_S2@meta.data$batch &lt;- &quot;ds.12_N2&quot;

# Here, we are assigning a batch identitiy to cells from each 10x library

nGreen_budding1@meta.data$batch &lt;- &quot;10x.bud1&quot;
nGreen_budding2@meta.data$batch &lt;- &quot;10x.bud2&quot;
nGreen@meta.data$batch &lt;- &quot;10x.nGreen&quot;
PN@meta.data$batch &lt;- &quot;10x.PN&quot;</code></pre>
<p>We then normalized each library using SCT Transform, regressing out
variables related to the modules scores for the stress genes and the
percentage of mitochondrial RNA reads. We used the SCT Integration
workflow to create the initial integrated dataset by finding common
anchors between all libraries. We used 3000 features for the initial
integration.<br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># Integrate all single cell data using SCTransform ---------------

# Here we are using the SCT transform function to integrate all data sets by first finding common anchors between all libraries 
# As stated in the section prior, through preliminary cluster analysis we decided to remove drop-seq library D06_FM_S1 (contained 68 cells), because it was giving errors during integration. This could perhaps be due to the too few number of cells within the library

# Combine all single cell RNAseq data sets into a list
all_single_cell_data &lt;- c(nGreen_budding1, nGreen_budding2, nGreen, PN, D01_D1_S1, D01_P2_S4, D02_CO_S2, D02_P1_S3, D02_PB_S4, D03_KI_S1, D03_MA_S2, D03_FM_S3, D06_MA_S3, D06_KI_S4, D11_PO_S1, D11_BU_S2, D12_N1_S1, D12_N2_S2)

# Apply SCT transform to all data sets in the list, regressing out variables related to the modules scores for the stress genes (see section: Add in module scores) as well as percent.mt
all_single_cell_data &lt;- lapply(X = all_single_cell_data, FUN = SCTransform, method = &quot;glmGamPoi&quot;, vars.to.regress = c(&quot;Stress_genes1&quot;, &quot;percent.mt&quot;))

# Choosing top 3000 features to use when integrating the data sets. Features are ranked by the data sets they are found to be variable in
all_single_cell_data_features &lt;- SelectIntegrationFeatures(object.list = all_single_cell_data, nfeatures = 3000)

all_single_cell_data &lt;- PrepSCTIntegration(object.list = all_single_cell_data, anchor.features = all_single_cell_data_features)

# Finds a set of anchors between a list of Seurat objects
all_single_cell_data_anchors &lt;- FindIntegrationAnchors(object.list = all_single_cell_data, normalization.method = &quot;SCT&quot;, anchor.features = all_single_cell_data_features)

# Performs dataset integration using anchor set
hydra.neuron.seurat &lt;- IntegrateData(anchorset = all_single_cell_data_anchors, normalization.method = &quot;SCT&quot;)</code></pre>
<p>We next calculated the first 40 principle components (PCs) of the
integrated dataset and plotted the variance explained by each component.
This allowed us to estimate the approximate dimensionality of the
dataset.<br></p>
<p>To calculate which PCs we should use (where they start to elbow), we
find two data points and take the minimum of those two points:<br> 1)
The point where the principal components only contribute 5% of standard
deviation and the principal components cumulatively contribute 90% of
the standard deviation. 2) The point where the percent change in
variation between the consecutive PCs is less than 0.1%.<br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># PCA + Cluster Analyses, hydra.integrated.sct --------------------------------------------------

# Next we will perform an initial cluster analysis on the integrated data. This is not so much the step where we care about how the UMAP looks, but rather where we want to weed out non-neuronal cells, such as nematocytes and gland cells which tend to be picked up in the nGreen line. After we perform subsetting and removal of non-neuronal cells, we will recluster the data and then work on making the UMAP pretty

# Here, we will perform PCA on the integrated data. 
# When running sctransform-based workflows, including integration, do not run the ScaleData() function prior to PCA. Note that this single command (SCT) replaces NormalizeData(), ScaleData(), and FindVariableFeatures().
hydra.neuron.seurat &lt;- RunPCA(hydra.neuron.seurat, npcs = 40, verbose = FALSE)

# Determine percent of variation associated with each PC
pct &lt;- hydra.neuron.seurat[[&quot;pca&quot;]]@stdev / sum(hydra.neuron.seurat[[&quot;pca&quot;]]@stdev) * 100

# Calculate cumulative percents for each PC
cumu &lt;- cumsum(pct)

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 &lt;- which(cumu &gt; 90 &amp; pct &lt; 5)[1]

#this returns PC # 31
co1

# Determine the difference between variation of PC and subsequent PC to determine the PC where the percent change in variation between consecutive PCs is less than 0.1%:
co2 &lt;- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) &gt; 0.1), decreasing = T)[1] + 1

# last point where change of % of variation is more than 0.1%.
# this returns PC # 25
co2

# Minimum of the two calculation
pcs &lt;- min(co1, co2)

# Create a dataframe with values
plot_df &lt;- data.frame(pct = pct, 
                      cumu = cumu, 
                      rank = 1:length(pct))

# Elbow plot to visualize 
# saved 8 x 12, hydra.neuron.seurat_elbow_plot_percents_initial_clustering
ggplot(plot_df, aes(cumu, pct, label = rank, color = rank &gt; pcs)) + 
  geom_text() + 
  geom_vline(xintercept = 90, color = &quot;grey&quot;) + 
  geom_hline(yintercept = min(pct[pct &gt; 5]), color = &quot;grey&quot;) +
  theme_bw()</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/integrated/hydra.integrated.sct_col.Elbow_initial_clustering.png"
alt="Init. Int. Elbow Plot" />
<div class="figcaption">Init. Int. Elbow Plot</div>
</div>
<p>For the initial clustering of this integrated dataset, we used the
first 25 PCs (calculated as the last point where change of % of
variation is more than 0.1%.) to generate a UMAP and to find clusters
using the Louvain algorithm with a resolution of 0.8. <br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code>hydra.neuron.seurat &lt;- RunUMAP(hydra.neuron.seurat, reduction = &quot;pca&quot;, dims = 1:25)
hydra.neuron.seurat &lt;- FindNeighbors(hydra.neuron.seurat, dim = 1:25)
hydra.neuron.seurat &lt;- FindClusters(hydra.neuron.seurat, resolution = 0.8)

#plot cluster groupings on umap 
DimPlot(hydra.neuron.seurat, reduction = &quot;umap&quot;, label = T) + NoLegend()</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/integrated/hydra.integrated.sct_UMAP.png"
alt="Initial Integration" />
<div class="figcaption">Initial Integration</div>
</div>
<p>We invested how integrated the data was by plotting umaps colored or
split by batch data.</p>
<pre class="r"><code>#Plot batch/library groupings on umap
DimPlot(hydra.neuron.seurat, reduction = &quot;umap&quot;, group.by = &quot;batch&quot;)</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/seurat/integrated/hydra.integrated.sct_UMAP_batch_initial_clustering.png" /></p>
<pre class="r"><code>#Assess each batch/library contribution to each cluster
DimPlot(hydra.neuron.seurat, reduction = &quot;umap&quot;, split.by = &quot;batch&quot;, ncol = 6) + NoLegend()</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/seurat/integrated/hydra.integrated.sct_UMAP_batch_split_initial_clustering.png" />
To ensure all all non-neuronal cells had been removed from the dataset,
we again plotted known molecular markers for nematocytes and gland
cells. We did not find any nematocyte or gland cell clusters in the
initial integegrated dataset.</p>
<p>Now that all single cell data sets have been integrated and basic
clustering was performed on the integrated object, we plotted nematocyte
and gland cell molecular markers and didn’t identify any nematocyte or
gland cell clusters. We removed cluster 26 from the object after
plotting stress genes markers and percent mitochondrial reads. We
believe cluster 26 is likely composed of highly stressed cells. <br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code>#Plot percent mitochondrial reads on umap
FeaturePlot(hydra.integrated.sct, &quot;percent.mt&quot;, label = T)</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/integrated/hydra.integrated.sct_UMAP_percent.mt_initial_clustering.png"
alt="Percent Mitochondrial Reads: Init. Int." />
<div class="figcaption">Percent Mitochondrial Reads: Init. Int.</div>
</div>
<pre class="r"><code># Ensure active assay is the SCT assay
DefaultAssay(hydra.neuron.seurat) &lt;- &quot;SCT&quot;


# Plot genes contributing to stress module score on umap
p1 &lt;- FeaturePlot(hydra.neuron.seurat, &quot;G027286&quot;) 
p2 &lt;- FeaturePlot(hydra.neuron.seurat, &quot;G014159&quot;) 
p3 &lt;- FeaturePlot(hydra.neuron.seurat, &quot;MT-16S&quot;) 
p4 &lt;- FeaturePlot(hydra.neuron.seurat, &quot;G015960&quot;) 
grid.arrange(p1, p2, p3, p4, ncol=2,top=&quot;cl 26 Stres markers&quot;)</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/integrated/hydra.integrated.sct_cl_26_stress_markers.png"
alt="Stress Markers: Init. Int." />
<div class="figcaption">Stress Markers: Init. Int.</div>
</div>
<pre class="r"><code># Remove cluster 26 - &quot;stress cluster&quot;
clusters_to_subset &lt;- c(&quot;0&quot;,  &quot;1&quot;,  &quot;2&quot;,  &quot;3&quot;,  &quot;4&quot;,  &quot;5&quot;,  &quot;6&quot;,  &quot;7&quot;,  &quot;8&quot;,  &quot;9&quot;,  &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, &quot;19&quot;, &quot;20&quot;, &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, &quot;27&quot;, &quot;28&quot;, &quot;29&quot;, &quot;30&quot;)

hydra.neuron.seurat &lt;- subset(hydra.neuron.seurat, idents = clusters_to_subset)</code></pre>
<!-- headings -->
<a id="item-four"></a>
<h3>
Final Integration and Clustering
</h3>
<p>After arriving at the final set of cells following the removal of
non-neuronal and other problematic cells, we performed one last round of
integration, PCA, clustering, and UMAP analysis.<br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># FINAL DATA INTEGRATION, PCA, AND CLUSTER ANALYSIS ------------------

# Assign batch identities to cells from each library -----------------------------------

#Now that we&#39;ve removed a non-neural cluster from the initial clustering, we will reintegrate the data. As before, we will extract each library from the integrated seurat object, 

# Switch the active assay to RNA
DefaultAssay(hydra.neuron.seurat) &lt;- &quot;RNA&quot;

# Getting cells from each batch.

dsp1 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;D01_D1_S1&quot;]
dsp2 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;D01_P2_S4&quot;]
dsp3 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;D02_CO_S2&quot;]
dsp4 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;D02_P1_S3&quot;]
dsp5 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;D02_PB_S4&quot;]
dsp6 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;D03_KI_S1&quot;]
dsp7 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;D03_MA_S2&quot;]
dsp8 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;D03_FM_S3&quot;]
dsp9 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;D06_MA_S3&quot;]
dsp10 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;D06_KI_S4&quot;]
dsp11 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;D11_PO_S1&quot;]
dsp12 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;D11_BU_S2&quot;]
dsp13 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;D12_N1_S1&quot;]
dsp14 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;D12_N2_S2&quot;]
b1 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;budding1&quot;]
b2 &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;budding2&quot;]
nG_tenx &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;neonGreen&quot;]
PN_tenx &lt;- rownames(hydra.neuron.seurat@meta.data)[hydra.neuron.seurat@meta.data[,&quot;orig.ident&quot;] == &quot;Pan-neuro&quot;]

# Here, we are subsetting cells from each drop-seq library from the larger drop-seq matrix into their own objects
D01_D1_S1 &lt;- subset(hydra.neuron.seurat, cells = dsp1)
D01_D1_S1@meta.data$batch &lt;- &quot;ds.01_D1&quot;

D01_P2_S4 &lt;- subset(hydra.neuron.seurat, cells = dsp2)
D01_P2_S4@meta.data$batch &lt;- &quot;ds.01_P2&quot;

D02_CO_S2 &lt;- subset(hydra.neuron.seurat, cells = dsp3)
D02_CO_S2@meta.data$batch &lt;- &quot;ds.02_CO&quot;

D02_P1_S3 &lt;- subset(hydra.neuron.seurat, cells = dsp4)
D02_P1_S3@meta.data$batch &lt;- &quot;ds.02_P1&quot;

D02_PB_S4 &lt;- subset(hydra.neuron.seurat, cells = dsp5)
D02_PB_S4@meta.data$batch &lt;- &quot;ds.02_PB&quot;

D03_KI_S1 &lt;- subset(hydra.neuron.seurat, cells = dsp6)
D03_KI_S1@meta.data$batch &lt;- &quot;ds.03_KI&quot;

D03_MA_S2 &lt;- subset(hydra.neuron.seurat, cells = dsp7)
D03_MA_S2@meta.data$batch &lt;- &quot;ds.03_MA&quot;

D03_FM_S3 &lt;- subset(hydra.neuron.seurat, cells = dsp8)
D03_FM_S3@meta.data$batch &lt;- &quot;ds.03_FM&quot;

D06_MA_S3 &lt;- subset(hydra.neuron.seurat, cells = dsp9)
D06_MA_S3@meta.data$batch &lt;- &quot;ds.06_MA&quot;

D06_KI_S4 &lt;- subset(hydra.neuron.seurat, cells = dsp10)
D06_KI_S4@meta.data$batch &lt;- &quot;ds.06_KI&quot;

D11_PO_S1 &lt;- subset(hydra.neuron.seurat, cells = dsp11)
D11_PO_S1@meta.data$batch &lt;- &quot;ds.11_PO&quot;

D11_BU_S2 &lt;- subset(hydra.neuron.seurat, cells = dsp12)
D11_BU_S2@meta.data$batch &lt;- &quot;ds.11_BU&quot;

D12_N1_S1 &lt;- subset(hydra.neuron.seurat, cells = dsp13)
D12_N1_S1@meta.data$batch &lt;- &quot;ds.12_N1&quot;

D12_N2_S2 &lt;- subset(hydra.neuron.seurat, cells = dsp14)
D12_N2_S2@meta.data$batch &lt;- &quot;ds.12_N2&quot;

# Extracting the four 10x libraries

#budding1 10x cells
b1ten_x &lt;- subset(hydra.neuron.seurat, cells = b1)
b1ten_x@meta.data$batch &lt;- &quot;10x.bud1&quot;

#budding2 10x cells
b2ten_x &lt;- subset(hydra.neuron.seurat, cells = b2)
b2ten_x@meta.data$batch &lt;- &quot;10x.bud2&quot;

#nGreen 10x cells
nGreen_tenx &lt;- subset(hydra.neuron.seurat, cells = nG_tenx)
nGreen_tenx@meta.data$batch &lt;- &quot;10x.nGreen&quot;

#PN 10x cells
Pan_neuro_tenx &lt;- subset(hydra.neuron.seurat, cells = PN_tenx)
Pan_neuro_tenx@meta.data$batch &lt;- &quot;10x.PN&quot;


# Add in module scores ----------------------------------------------------

# We will assign module scores, as performed above, with the same list of genes associated with 1) batch effects and 2) stress.

stress_genes_list &lt;- list(c(&quot;MT-16S&quot;,
                            &quot;G014159&quot;,
                            &quot;G027286&quot;,
                            &quot;G015960&quot;,
                            &quot;G010241&quot;,
                            &quot;G009485&quot;,
                            &quot;G001468&quot;,
                            &quot;G022617&quot;,
                            &quot;G021648&quot;))

b1ten_x &lt;- AddModuleScore(
  object = b1ten_x,
  features = stress_genes_list,
  name = &quot;Stress_genes&quot;
)

b2ten_x &lt;- AddModuleScore(
  object = b2ten_x,
  features = stress_genes_list,
  name = &quot;Stress_genes&quot;
)

nGreen_tenx &lt;- AddModuleScore(
  object = nGreen_tenx,
  features = stress_genes_list,
  name = &quot;Stress_genes&quot;
)

Pan_neuro_tenx &lt;- AddModuleScore(
  object = Pan_neuro_tenx,
  features = stress_genes_list,
  name = &quot;Stress_genes&quot;
)


# Re-integrate remaining data using SCT -----------------------------------

#combine the data sets
all_single_cell_data &lt;- c(b1ten_x, b2ten_x, nGreen_tenx, Pan_neuro_tenx, D01_D1_S1, D01_P2_S4, D02_CO_S2, D02_P1_S3, D02_PB_S4, D03_KI_S1, D03_MA_S2, D03_FM_S3, D06_MA_S3, D06_KI_S4, D11_PO_S1, D11_BU_S2, D12_N1_S1, D12_N2_S2)

# doing stress genes, can also try batch
all_single_cell_data &lt;- lapply(X = all_single_cell_data, FUN = SCTransform, vars.to.regress = c(&quot;Stress_genes1&quot;, &quot;percent.mt&quot;))

all_single_cell_data_features &lt;- SelectIntegrationFeatures(object.list = all_single_cell_data, nfeatures = 3000)

all_single_cell_data &lt;- PrepSCTIntegration(object.list = all_single_cell_data, anchor.features = all_single_cell_data_features)

all_single_cell_data_anchors &lt;- FindIntegrationAnchors(object.list = all_single_cell_data, normalization.method = &quot;SCT&quot;, anchor.features = all_single_cell_data_features)

hydra.neuron.seurat &lt;- IntegrateData(anchorset = all_single_cell_data_anchors, normalization.method = &quot;SCT&quot;)


# Final PCA + Cluster Analyses --------------------------------------------------

# Next we will perform a cluster analysis on the integrated data.

# Here, we will perform PCA on the integrated data. 

# Make sure that the default assay is integrated
DefaultAssay(hydra.neuron.seurat) &lt;- &quot;integrated&quot;

# Run PCA
hydra.neuron.seurat &lt;- RunPCA(hydra.neuron.seurat, npcs = 40, verbose = FALSE)

# To calculate which principal components we should use (where they start to elbow), we find two data points and take their minimum: 
# 1) The point where the principal components only contribute 5% of standard deviation and the principal components cumulatively contribute 90% of the standard deviation.
# 2) The point where the percent change in variation between the consecutive PCs is less than 0.1%.

# Determine percent of variation associated with each PC
pct &lt;- hydra.neuron.seurat[[&quot;pca&quot;]]@stdev / sum(hydra.neuron.seurat[[&quot;pca&quot;]]@stdev) * 100

# Calculate cumulative percents for each PC
cumu &lt;- cumsum(pct)

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 &lt;- which(cumu &gt; 90 &amp; pct &lt; 5)[1]

#this returns PC # 31
co1

# Determine the difference between variation of PC and subsequent PC to determine the PC where the percent change in variation between consecutive PCs is less than 0.1%:
co2 &lt;- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) &gt; 0.1), decreasing = T)[1] + 1

# last point where change of % of variation is more than 0.1%.
# this returns PC # 21
co2

# Minimum of the two calculation
pcs &lt;- min(co1, co2)

# Create a dataframe with values
plot_df &lt;- data.frame(pct = pct, 
                      cumu = cumu, 
                      rank = 1:length(pct))

# Elbow plot to visualize 
# saved 8 x 12, hydra.neuron.seurat_elbow_plot_percents
ggplot(plot_df, aes(cumu, pct, label = rank, color = rank &gt; pcs)) + 
  geom_text() + 
  geom_vline(xintercept = 90, color = &quot;grey&quot;) + 
  geom_hline(yintercept = min(pct[pct &gt; 5]), color = &quot;grey&quot;) +
  theme_bw()</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/seurat/final/hydra.neuron.seurat_elbow_plot_percents.png"
alt="Final Integration Elbow Plot" /> After trying several combinations
of different PCs, we have opted to use the first 21 PCs for our final
clustering with a resolution of 0.8.<br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code>hydra.neuron.seurat &lt;- RunUMAP(hydra.neuron.seurat, reduction = &quot;pca&quot;, dims = 1:21, min.dist = .25, spread = 0.7)
hydra.neuron.seurat &lt;- FindNeighbors(hydra.neuron.seurat, dim = 1:21)
hydra.neuron.seurat &lt;- FindClusters(hydra.neuron.seurat, resolution = 0.8)

#Plot cluster groupings on umap
DimPlot(hydra.neuron.seurat, reduction = &quot;umap&quot;, label = T) + NoLegend()</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/final/hydra.neuron.seurat_UMAP_final_clustering.png"
alt="Final Integration" />
<div class="figcaption">Final Integration</div>
</div>
<pre class="r"><code>#Assess batch contributions to each cluster
DimPlot(hydra.neuron.seurat, reduction = &quot;umap&quot;, split.by = &quot;batch&quot;, ncol = 6, label = T) + NoLegend()</code></pre>
<img
src="resources/01_HydraNeuronAtlas/seurat/final/hydra.neuron.seurat_UMAP_batch_split_final_clustering.png" />
<!-- headings --> <a id="item-five"></a>
<h3>
Annotating the Hydra Neuron Single Cell Atlas
</h3>
<p>In our previous study (Siebert 2019) we identified 8 neuron types
that make up the endodermal (3 neuron types) and ectodermal (5 neuron
types) nerve nets. The 5 neuron types that reside in the ectodermal
layer of the animal were further divided into 9 subtypes. In Siebert
2019 we identified unique combinations of marker genes to annotate each
of the 12 neuron subtypes (marker combinations listed below for each
subtype).<br></p>
<p><strong>Neural Progenitors:</strong> SoxC (G021326, Siebert 2019)
&amp; Myb (G020130, Siebert 2019)<br> <strong>Endodermal
Neurons:</strong> budhead (G011613, Siebert 2019)<br>
<strong>en1:</strong> ndf1 (G008286, Siebert 2019)<br>
<strong>en2:</strong> alpha-latroxin-Lhe1a-like (G004963, Siebert
2019)<br> <strong>en3:</strong> ptf1-a (G022927, Cazet 2023)<br>
<strong>ec1A:</strong> Hym176A (G016173, Noro 2019), Hym176B (G016170,
Noro 2019), Hym176D (G016171, Noro 2019)<br> <strong>ec1B:</strong>
t28450 (G017140, Siebert 2019), Hym176A (G016173, Noro 2019), Hym176B
(G016170, Noro 2019), Hym176E (G016169, Noro 2019) <br>
<strong>e2:</strong> RFa-C (G017220, Moosler 1996; Darmer 1998), cNASH
(G021625, Hayakawa 2004), cNOT (G003891, Siebert 2019), prdl-a (G001197,
Siebert 2019)<br> <strong>ec3A:</strong> GLWamide (G018128, Takahashi
1997), Hym355 (G004115, Takahashi 2000), cNOT (G003891, Siebert
2019)<br> <strong>ec3A:</strong> GLWamide (G018128, Takahashi 1997),
Hym355 (G004115, Takahashi 2000) <br> <strong>ec3A:</strong> GLWamide
(G018128, Takahashi 1997), Hym355 (G004115, Takahashi 2000) <br>
<strong>ec4A:</strong> RFa-A (G017228, Moosler 1996; Darmer 1998), Rfa-B
(G017227, Moosler 1996; Darmer 1998), RFa-D (G017226, Moosler 1996;
Darmer 1998), prdl-a (G001197, Siebert 2019) <br> <strong>ec4B:</strong>
Rfa-A (G017228, Moosler 1996; Darmer 1998), RFa-B (G017227, Moosler
1996; Darmer 1998) (Note: RFa-B has stronger expression in ec4B than
ec4A in Siebert 2019) <br> <strong>ec5:</strong> RFa-C (G017220, Moosler
1996; Darmer 1998) <br></p>
<p>To get a sense of the cellular identity of the neuronal clusters in
our dataset, we visualized the expression of known neuronal type/subtype
markers from Siebert 2019.</p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code>library(ggtext) # needed for the custom titles

# Load in known markers file
known.markers &lt;- read.csv(&quot;resources/known.markers.siebert.cazet.csv&quot;)
colnames(known.markers) &lt;- c(&quot;geneID&quot;, &quot;geneName&quot;, &quot;cellType&quot;)

# Begin code to create FeaturePlot grid

# List to store plots for loop populates
plots &lt;- list()

# Make sure we are plotting the normalized data
DefaultAssay(hydra.neuron.seurat) &lt;- &quot;SCT&quot;

# Generate FeaturePlots with custom titles
for (i in 1:nrow(known.markers)) {
  df &lt;- known.markers
  
  gene_id &lt;- df$geneID[i]
  gene_name &lt;- df$geneName[i]
  cell_type &lt;- df$cellType[i]
  
  # Construct the multi-line title
  custom_title &lt;- paste0(
    &quot;**&quot;, cell_type, &quot;**&lt;br&gt;&quot;, # Add cell type info to each plot then add line break
    ifelse(gene_name != &quot;&quot;, paste0(&quot;*&quot;, gene_name, &quot;*&lt;br&gt;&quot;), &quot;&lt;br&gt;&quot;),  # Add gene name followed by line break. 
    # Blank line is added if the gene name is empty
    &quot;*&quot;, gene_id, &quot;*&quot; # Always include gene ID
  )
  
  p &lt;- FeaturePlot(hydra.neuron.seurat, features = gene_id, combine = FALSE, order = T)[[1]] + NoAxes()
  p &lt;- p + ggtitle(custom_title) +
    theme(
      plot.title = element_markdown(hjust = 0.5, size = 10)  # Use element_markdown for interpretation
    ) + 
    theme(
      legend.text = element_text(size = 7.5)     # Legend text font size
    ) +
    guides(
      color = guide_colorbar(
        barwidth = 0.5,  # Width of the legend bar
        barheight = 5  # Height of the legend bar
      )
    )
  plots[[i]] &lt;- p
}

#Add UMAP grouped by clusters
plots[[24]] &lt;- DimPlot(hydra.neuron.seurat, group.by = &quot;integrated_snn_res.0.8&quot;, label = T) + NoLegend()

# Combine plots into a grid
grid &lt;- wrap_plots(plots, ncol = 3)
print(grid)</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/seurat/final/final_known.markers.png"
alt="Previous ID’d Molecular Markers" /> Plotting known markers for
interstitial stem cells and neuro progenitors we identified ISCs as
cluster 8 with to neural progenitor populations radiating out from it
(clusters 6 and 7). We identified clusters 4, 20, 10, and 12 as
endodermal neurons by plotting the expression of <em>budhead</em>
(Siebert, 2019). We identified 8 neuron types (3 types located in the
endodermal nerve net prefixed by “en” and 5 types located in the
ectodermal nerve net prefixed by “ec”) by expression of known markers.
Also, we were able to resolve the 12 neuron subtypes previously
identifed (en1-3, ec1A/B, ec2, ec3A/B/C, ec4A/4B, ec5) by assessing the
expression patterns of known combinations of molecular markers. By
increasing the size of our dataset from 3,500 to 35,000 neurons we can
now see the connections between differenitated neuron subtypes and
neural progenitors which shows we were able to capture transition states
during differentiation.</p>
<p>In addition to capturing differentiation transition states by
increasing the nuuber of neurons in the dataset, we captured 4
unidentified clusters (clusters 18, 21, 28, &amp; 29). Unknown cluster
29 was connected to the en1 cluster. Upon further investigation, we
concluded that the markers contributing to this cluster were stress
related and removed these cells from the dataset (cluster 29 likely
originated from cluster 24 in the initial integration object which also
showed high expression of stress markers). The three remaining unknown
clusters expressed markers associated with ec1A, ec1B, and ec5 neurons
(Hym176 neuropeptides in particular which characterize those neuron
types). At this point, it was unclear if these unknown clusters
represent distinct neuron subtypes or transition states between
differentiated ec1/5 neurons transdifferentiating into a different
subtype.</p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># Preliminary renaming of clusters. FindMarkers() will be called for each subtype. Numeric Seurat Clusters were collapsed into 15 differentiated neuron subtypes (12 known + 3 unknown), 4 neuron type precursors, 2 neural progenitors, and stem cells (ISCs).
hydra.neuron.seurat &lt;- RenameIdents(hydra.neuron.seurat, 
                                    `0` = &quot;ec2&quot;,
                                    `1` = &quot;ec1B&quot;, 
                                    `2` = &quot;ec4A&quot;, 
                                    `3` = &quot;ec1B&quot;, 
                                    `4` = &quot;en2&quot;, 
                                    `5` = &quot;ec4A&quot;, 
                                    `6` = &quot;progen1&quot;, 
                                    `7` = &quot;progen2&quot;, 
                                    `8` = &quot;ISC&quot;, 
                                    `9` = &quot;ec1B&quot;, 
                                    `10` = &quot;en3&quot;, 
                                    `11` = &quot;ec5&quot;, 
                                    `12` = &quot;en1&quot;, 
                                    `13` = &quot;ec3C&quot;,
                                    `14` = &quot;ec3B&quot;, 
                                    `15` = &quot;ec1A&quot;, 
                                    `16` = &quot;ec1B&quot;,
                                    `17` = &quot;ec1 prec.&quot;, 
                                    `18` = &quot;unk1&quot;,
                                    `19` = &quot;ec3A&quot;, 
                                    `20` = &quot;en2&quot;,
                                    `21` = &quot;unk3&quot;,
                                    `22` = &quot;ec2 prec.&quot;, 
                                    `23` = &quot;ec3 prec.&quot;,
                                    `24` = &quot;endo prec.&quot;, 
                                    `25` = &quot;ec4B&quot;,
                                    `27` = &quot;ec4B&quot;,
                                    `28` = &quot;unk2&quot;)

DimPlot(hydra.neuron.seurat, label = T) + NoLegend()</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/seurat/final/final_unks.png" /> With
the increase in number of neurons, we sought to identify individual
neuron subtype specific markers 1) to determine the identity of these
unknown clusters and whether or not they are distinct neuron subtypes
and 2) better assess structure of the <em>Hydra</em> nerve net and
construct a map of where each neuron subtype is located in the adult
animal through fluorescent in situ hybridization (FISH) and
hybridization chain reaction (HCR) experiments. We ran
<code>Seurat::FindAllMarkers(object, min.pct = 0.25, only.pos = T)</code>
to find candidate molecular markers for each unknown cluster to find
candidate markers to test <em>in vivo</em>. Each candidate marker was
plotted on the whole <em>Hydra</em> dataset to ensure that they were
neuron specific before proceeding to <em>in vivo</em> experiments.</p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code>## Find molecular markers for Neuron Subtypes + Unknown Clusters ---------------------------------------
# Goal: Find markers to characterize each neuron subtype + unknown neuroun clusters in vivo via FISH/HCR.

# Run FindAllMarkers() to find top markers for each cluster
hy.neuron.markers &lt;- FindAllMarkers(hydra.neuron.seurat, min.pct = 0.25, only.pos = T)

# Extract top 5 markers for each cluster and store as new data.frame
top.5.df &lt;- hy.neuron.markers %&gt;%
  group_by(cluster) %&gt;%
  slice_min(order_by = p_val_adj, n = 5, with_ties = FALSE)

# Plot top 5 markers for each cluster on the neuron data to ensure they are specific (FLAG!: SHOULD REALLY CHECK THIS CODE)
plots &lt;- list()
for (clus in unique(top.5.df$cluster)) {
  # Subset top 5 genes for this cluster
  df.temp &lt;- top.5.df %&gt;% filter(cluster == clus)
  
  # Create FeaturePlots for each gene
  plot.list &lt;- lapply(df.temp$gene, function(gene) {
    FeaturePlot(hydra.neuron.seurat, features = gene) + ggtitle(paste(&quot;Cluster&quot;, clus, &quot;-&quot;, gene))
  })
  
  # Combine plots into a grid
  combined &lt;- wrap_plots(plot.list, ncol = 3)
  
  # Each grid of cluster plots will print individually (so plots for ec1A will print together, then 1B, and so on)
  print(combined)
}

# Plot top 5 markers on whole animal data to make sure they aren&#39;t expressed in any nonNeuronal cell tyeps.
for (clus in unique(top.5.df$cluster)) {
  # Subset top 5 genes for this cluster
  df.temp &lt;- top.5.df %&gt;% filter(cluster == clus)
  
  # Create FeaturePlots for each gene
  plot.list &lt;- lapply(df.temp$gene, function(gene) {
    FeaturePlot(whole.hydra, features = gene) + ggtitle(paste(&quot;Cluster&quot;, clus, &quot;-&quot;, gene))
  })
  
  # Combine plots into a grid
  combined &lt;- wrap_plots(plot.list, ncol = 3)
  
  # Each grid of cluster plots will print individually (so plots for ec1A will print together, then 1B, and so on)
  print(combined)
}


# The top molecular markers contributing to &quot;en1_unk&quot; are stress related. Therefore, &quot;en1_unk&quot; (formerly `29`) was removed from the dataset 
cell.types &lt;- levels(hydra.neuron.seurat)
cell.types &lt;- cell.types[cell.types != &quot;en1_unk&quot;]
cell.types

hydra.neuron.seurat &lt;- subset(hydra.neuron.seurat, idents = cell.types)</code></pre>
<p>With this strategy we were able to determine each unknown cluster is
in fact a distinct neuron subtype with distinct locations along the body
axis in the ectodermal nerve net (unk1 at the base of the tentacles,
unk2 slightly more oral than unk1 in hypostome, and unk3 in the basal
disk). The unknown populations were renamed to fit our proposed nervous
system naming scheme from unk1 to ec1C, unk2 to ec1E, and unk3 to ec1D.
We were also able to construct a map of the <em>Hydra</em> nerve net by
placing each neuron in a specific region of the animal. <img
src="resources/01_HydraNeuronAtlas/seurat/NeuronMap.png"
alt="Neuron Subtype Spatial Map" /></p>
<p>Below we present the molecular markers used to identify each neuron
subtype plotted on the final integrated UMAP and DotPlot from this
study, and the whole <em>Hydra</em> UMAP collected in Siebert 2019 and
remapped in Cazet 2023.</p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># Plotting newly identified and validated neuron subtype markers

df &lt;- data.frame(
  geneID = c(&quot;G004515&quot;, &quot;G002332&quot;, &quot;G003730&quot;, &quot;G020130&quot;, 
             &quot;G011613&quot;, &quot;G008286&quot;, &quot;G004963&quot;, &quot;G022927&quot;,
             &quot;G026993&quot;, &quot;G017140&quot;, &quot;G007791&quot;, &quot;G004200&quot;, &quot;G003886&quot;,
             &quot;G007969&quot;, &quot;G021930&quot;, &quot;G004106&quot;, &quot;G026484&quot;, 
             &quot;G017226&quot;, &quot;G017227&quot;, #this last one is new RFamide B ec4b
             &quot;G016165&quot;),
  geneName = c(&quot;elav2&quot;, &quot;hy-icell1&quot;, &quot;myc3&quot;, &quot;myb&quot;,
               &quot;budhead&quot;, &quot;ndf1&quot;, &quot;alpha-latroxin-Lhe1a-like&quot;, &quot;aef1&quot;,
               &quot;&quot;, &quot;&quot;, &quot;kcnb1&quot;, &quot;opsd&quot;, &quot;&quot;,
               &quot;litaf&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, 
               &quot;rfamide D&quot;, &quot;rfamide B&quot;,
               &quot;hym176c&quot;),
  cellType = c(&quot;Neurons + Neural Progenitors&quot;, &quot;Interstitial Stem Cells&quot;, &quot;Neural Progenitors&quot;, &quot;Neural Progenitors&quot;,
               &quot;Endodermal Neurons&quot;, &quot;en1&quot;, &quot;en2&quot;, &quot;en3&quot;, 
               &quot;ec1A&quot;, &quot;ec1B&quot;, &quot;ec1C&quot;, &quot;ec1D&quot;, &quot;ec1E&quot;,
               &quot;ec2&quot;, &quot;ec3A&quot;, &quot;ec3B&quot;, &quot;ec3C&quot;,
               &quot;ec4A&quot;, &quot;ec4B&quot;, &quot;ec5&quot;)
)

library(ggtext)
# List to store plots
plots &lt;- list()

# Generate FeaturePlots with custom titles
for (i in 1:nrow(df)) {
  gene_id &lt;- df$geneID[i]
  gene_name &lt;- df$geneName[i]
  cell_type &lt;- df$cellType[i]
  
  # Construct the multi-line title
  custom_title &lt;- paste0(
    &quot;**&quot;, cell_type, &quot;**&lt;br&gt;&quot;,
    ifelse(gene_name != &quot;&quot;, paste0(&quot;*&quot;, gene_name, &quot;*&lt;br&gt;&quot;), &quot;&lt;br&gt;&quot;),  # Add blank line if gene name is missing
    &quot;*&quot;, gene_id, &quot;*&quot;                                                 # Always include gene ID
  )
  
  p &lt;- FeaturePlot(hydra.neuron.seurat, features = gene_id, combine = FALSE, order = T)[[1]] + NoAxes()
  p &lt;- p + ggtitle(custom_title) +
    theme(
      plot.title = element_markdown(hjust = 0.5, size = 10)  # Use element_markdown for interpretation
    ) + 
    theme(
      legend.text = element_text(size = 7.5)     # Legend text font size
    ) +
    guides(
      color = guide_colorbar(
        barwidth = 0.5,  # Width of the legend bar
        barheight = 5  # Height of the legend bar
      )
    )
  plots[[i]] &lt;- p
}

plots[[21]] &lt;- DimPlot(hydra.neuron.seurat, label = T, repel = T) + NoLegend()

# Combine plots into a grid
png(&quot;../GitHub/resources/seurat/final/final_new.markers.png&quot;,
    width = 800,
    height = 1600)
wrap_plots(plots, ncol = 3) #patchworkdev.off()
dev.off()</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/final/final_new.markers.png"
alt="New Molecular Markers: Neurons" />
<div class="figcaption">New Molecular Markers: Neurons</div>
</div>
<pre class="r"><code># Now on whole animal
# Plotting newly identified and validated neuron subtype markers

# clear plots
plots &lt;- list()

# Generate FeaturePlots with custom titles
for (i in 1:nrow(df)) {
  gene_id &lt;- df$geneID[i]
  gene_name &lt;- df$geneName[i]
  cell_type &lt;- df$cellType[i]
  
  # Construct the multi-line title
  custom_title &lt;- paste0(
    &quot;**&quot;, cell_type, &quot;**&lt;br&gt;&quot;,
    ifelse(gene_name != &quot;&quot;, paste0(&quot;*&quot;, gene_name, &quot;*&lt;br&gt;&quot;), &quot;&lt;br&gt;&quot;),  # Add blank line if gene name is missing
    &quot;*&quot;, gene_id, &quot;*&quot;                                                 # Always include gene ID
  )
  
  p &lt;- FeaturePlot(whole.animal, features = gene_id, combine = FALSE, order = T)[[1]] + NoAxes()
  p &lt;- p + ggtitle(custom_title) +
    theme(
      plot.title = element_markdown(hjust = 0.5, size = 10)  # Use element_markdown for interpretation
    ) + 
    theme(
      legend.text = element_text(size = 7.5)     # Legend text font size
    ) +
    guides(
      color = guide_colorbar(
        barwidth = 0.5,  # Width of the legend bar
        barheight = 5  # Height of the legend bar
      )
    )
  plots[[i]] &lt;- p
}

plots[[21]] &lt;- DimPlot(whole.animal)

# Combine plots into a grid
png(&quot;../GitHub/resources/seurat/final/whole.hydra_new.markers.png&quot;,
    width = 1000,
    height = 1600)
wrap_plots(plots, ncol = 3) #patchworkdev.off()
dev.off()</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/final/whole.hydra_new.markers.png"
alt="New Molecular Markers: Whole animal" />
<div class="figcaption">New Molecular Markers: Whole animal</div>
</div>
<p>Altogether, we confirm the presence of 8 neuronal types, 5 in the
ectodermal nerve net and 3 in the endodermal nerve net, as described in
Siebert 2019. We validate all twelve previously identified subtypes
(Siebert 2019) and identified 3 novel subtypes, for a total of 15
subtypes (12 in the ectoderm and 3 in the endoderm). Using newly
identified subtype-specific markers for <em>in vivo</em> validation and
characterization via imaging after FISH/HCR, we further assigned each
neuron subtype to anatomical location and functional class (sensory or
ganglion).</p>
<p>Finally, we changed the cluster identities to reflect the respective
neuron type and subtype with our newly proposed naming scheme (nerve net
(ec/en) followed by the type (1-5) followed by subtype (A-E)).<br></p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># Reset idents to seurat numeric clusters
Idents(hydra.neuron.seurat) &lt;- &quot;integrated_snn_res.0.8&quot;

# Final naming now to generate the &quot;short.ident&quot;
hydra.neuron.seurat &lt;- RenameIdents(hydra.neuron.seurat, 
                                    `0` = &quot;ec2&quot;,
                                    `1` = &quot;ec1B&quot;, 
                                    `2` = &quot;ec4A&quot;, 
                                    `3` = &quot;ec1B&quot;, 
                                    `4` = &quot;en2&quot;, 
                                    `5` = &quot;ec4A&quot;, 
                                    `6` = &quot;progen1&quot;, 
                                    `7` = &quot;progen2&quot;, 
                                    `8` = &quot;ISC&quot;, 
                                    `9` = &quot;ec1B&quot;, 
                                    `10` = &quot;en3&quot;, 
                                    `11` = &quot;ec5&quot;, 
                                    `12` = &quot;en1&quot;, 
                                    `13` = &quot;ec3C&quot;,
                                    `14` = &quot;ec3B&quot;, 
                                    `15` = &quot;ec1A&quot;, 
                                    `16` = &quot;ec1B&quot;,
                                    `17` = &quot;ec1 prec.&quot;, 
                                    `18` = &quot;ec1C&quot;,
                                    `19` = &quot;ec3A&quot;, 
                                    `20` = &quot;en2&quot;,
                                    `21` = &quot;ec1D&quot;,
                                    `22` = &quot;ec2 prec.&quot;, 
                                    `23` = &quot;ec3 prec.&quot;,
                                    `24` = &quot;endo prec.&quot;, 
                                    `25` = &quot;ec4B&quot;,
                                    `27` = &quot;ec4B&quot;,
                                    `28` = &quot;ec1E&quot;)

# Store new cell type cluster IDs in object metadata
hydra.neuron.seurat[[&quot;short.ident&quot;]] &lt;- Idents(object = hydra.neuron.seurat)

DimPlot(hydra.neuron.seurat, cols =
          c(&quot;ISC&quot; = &quot;#E86AA8&quot;, 
            &quot;progen1&quot; = &quot;#FFB14E&quot;, 
            &quot;progen2&quot; = &quot;#FFB14E&quot;, 
            &quot;endo prec.&quot; = &quot;#BC4643&quot;,
            &quot;en1&quot; = &quot;#3A84C6&quot;,
            &quot;en2&quot; = &quot;#F3766E&quot;, 
            &quot;en3&quot; = &quot;#6EB044&quot;, 
            &quot;ec1 prec.&quot; = &quot;#B879B4&quot;,
            &quot;ec1A&quot; = &quot;#21C3C0&quot;, 
            &quot;ec1B&quot; = &quot;#2E7948&quot;, 
            &quot;ec2 prec.&quot; = &quot;#F3466E&quot;, 
            &quot;ec2&quot; = &quot;#1FB3E8&quot;, 
            &quot;ec3 prec.&quot; = &quot;#D170AD&quot;,
            &quot;ec3A&quot; = &quot;#24B34B&quot;, 
            &quot;ec3B&quot; = &quot;#543777&quot;, 
            &quot;ec3C&quot; = &quot;#11BDD4&quot;, 
            &quot;ec4A&quot; = &quot;#D96F00&quot;, 
            &quot;ec4B&quot; = &quot;#2E7881&quot;,
            &quot;ec5&quot; = &quot;#8B84DC&quot;, 
            &quot;ec1C&quot; = &quot;#8190C8&quot;,
            &quot;ec1D&quot; = &quot;#64708E&quot;,
            &quot;ec1E&quot; = &quot;#F16999&quot; 
          ), label = T, pt.size = .09) + NoLegend()</code></pre>
<div class="float">
<img
src="resources/01_HydraNeuronAtlas/seurat/final/final_final.labs.png"
alt="Final Cluster Labeling" />
<div class="figcaption">Final Cluster Labeling</div>
</div>
<!-- headings -->
<a id="item-six"></a>
<h3>
Identifying Gene Co-Expression Programs Using Non-Negative Matrix
Factorization
</h3>
<p>Non-negative matrix factorization (NMF) is a dimensionality reduction
technique that breaks large and complex datasets into a relatively small
number of ‘parts’ that can be combined in an additive fashion to
represent any of the individual samples within the original dataset. In
the context of gene expression data, NMF describes the transcriptomes of
individual samples as a mixture of metagenes (i.e., a group of genes
with correlated expression) that, when combined in a particular way, can
be used to construct a given sample’s specific transcriptional
profile.</p>
<p>To generate this parts-based representation, NMF assumes that a data
matrix (in this case a digital gene expression matrix) can be
represented as the product of two matrices, called <strong>W</strong>
and <strong>H</strong>, that are constrained to only contain positive
values. For single-cell RNA expression data, <strong>W</strong> encodes
how strongly each gene contributes to each metagene (i.e., gene
weights), and <strong>H</strong> encodes how much each metagene
contributes to each cell transcriptome (i.e., cell weights).</p>
<p>If the original dataset is a matrix of n rows (genes) and m columns
(cells), <strong>W</strong> will be a n by <em>k</em> matrix and
<strong>H</strong> will be a <em>k</em> by m matrix. <em>k</em> is the
rank value, which determines how many parts the original dataset will be
broken into. There is no objectively optimal value of <em>k</em>, so
<em>k</em> needs to be estimated empirically for every dataset by
evaluating results across a range of values.</p>
<p>All that is required as input into the NMF algorithm is a gene
expression matrix and a value for <em>k</em>. NMF then initializes W and
H matrices and iteratively adjusts the values within each matrix until
the product of W x H produces as close an approximation of the original
expression matrix as possible.</p>
<p>To generate the initial input into the cNMF algorithm, we exported
the raw and normalized gene expression matrices from the Hydra atlas
Seurat object. We also exported the list of variable genes identified by
Seurat. The variable gene list is needed because cNMF restricts the
actual NMF analysis to only variable genes to reduce computation time,
and then extrapolates the results to the remaining genes.</p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code>####NMF prep####
rawC &lt;- t(as.matrix(hydra.neuron.seurat@assays$RNA@counts))
write.table(rawC,file=&quot;unfilt.whole.raw.counts.tsv&quot;,sep = &#39;\t&#39;, quote = F)
rm(rawC)

normC &lt;- t(as.matrix(hydra.neuron.seurat@assays$SCT@data))
write.table(normC,file=&quot;unfilt.whole.norm.counts.tsv&quot;,sep = &#39;\t&#39;, quote = F)
rm(normC)

#list of variable genes to look at
write.table(ds@assays$integrated@var.features, file = &#39;unfilt.whole.genes.tsv&#39;, row.names = F, col.names = F, quote = F)</code></pre>
<h4>
Performing a Course Sweep of K Values
</h4>
<p>As <em>k</em> needs to be determined empirically for each dataset, we
performed a broad sweep of <em>k</em> values from 15-70 in steps of five
so we could identify general <em>k</em> values that gave good results.
We used the prepare function within the cnmf.py script to set up this
initial run:</p>
<p>(<em>03_runPrep.sh</em>)</p>
<pre><code>#!/bin/bash
#SBATCH -p med
#SBATCH --job-name=prep
#SBATCH -c 4
#SBATCH -t 60-0
#SBATCH --mem=60G
#SBATCH --error=prep.err
#SBATCH --output=prep.out

source ~/.bash_profile

conda activate cnmf_env

python cNMF/cnmf.py prepare --name neuro_unfilt_course \
        -c unfilt.neuron.raw.counts.tsv \
        -k 15 20 25 30 35 40 45 50 55 60 65 70 \
        --n-iter 200 \
        --total-workers 30 \
        --seed 12345
        --tpm unfilt.neuron.norm.counts.tsv \
        --genes-file neuron.whole.genes.tsv</code></pre>
<p>We then ran the analysis using the following script:</p>
<p>(<em>03_cnmf/runFactorize.sh</em>)</p>
<pre><code>#!/bin/bash
#SBATCH --job-name=factorize
#SBATCH -p med
#SBATCH -c 2
#SBATCH -t 60-0
#SBATCH --array=0-29
#SBATCH --mem=24G
#SBATCH --error=factorize_%a.err
#SBATCH --output=factorize_%a.out

source ~/.bash_profile

conda activate cnmf_env

python cNMF/cnmf.py factorize --name neuro_unfilt_course --worker-index $SLURM_ARRAY_TASK_ID</code></pre>
<p>The results of NMF are sensitive to how the <strong>W</strong> and
<strong>H</strong> matrices are initialized. To ensure reproducibility,
cNMF performs the NMF analysis for each <em>k</em> value multiple times
(in the case of this analysis, we set this to 200 runs). This means that
the files from each of these independent runs need to be combined for
further analysis, which is done with the combine function:</p>
<p>(<em>03_cnmf/runCombine.sh</em>)</p>
<pre><code>#!/bin/bash
#SBATCH --job-name=combine
#SBATCH -p med
#SBATCH -c 1
#SBATCH -t 60-0
#SBATCH --mem=24G
#SBATCH --error=combine.err
#SBATCH --output=combine.out

source ~/.bash_profile

conda activate cnmf_env

python cNMF/cnmf.py combine --name neuro_unfilt_course</code></pre>
<p>The pooled results can then be evaluated for how well and how
reliably each <em>k</em> value approximated the original expression
data. Plots of such metrics are generated with the
<code>k_selection_plot</code> function:</p>
<p>(<em>03_cnmf/runKselect.sh</em>)</p>
<pre><code>#!/bin/bash
#SBATCH --job-name=combine
#SBATCH -p bigmemm 
#SBATCH -c 1
#SBATCH -t 60-0
#SBATCH --mem=24G
#SBATCH --error=combine.err
#SBATCH --output=combine.out

source ~/.bash_profile

conda activate cnmf_env

python ../cNMF/cnmf.py k_selection_plot --name neuro_unfilt_course</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/nmf/neuro_unfilt_course.k_selection.png"
alt="course k-selection" /> The blue line represents the variability in
results, with higher numbers indicating more consistent results from run
to run for a given <em>k</em> value. The red line indicates how well the
NMF results recapitulated the original expression matrix. Generally,
lower error values and higher stability values are desirable.</p>
<p>Often with NMF there are multiple local maxima for the stability
metric, essentially representing different possible resolutions for
looking at the data. In the case of this analysis, we saw that there
were two stability maxima, one for a <em>k</em> value of 30 and another
for a <em>k</em> value of 60. We opted to use the lower resolution
analysis for downstream analysis.</p>
<h4>
Performing a Fine Sweep of <em>k</em> Values
</h4>
<p>Because our initial <em>k</em> sweep moved in steps of five, we
needed to perform a second higher resolution sweep to identify the exact
<em>k</em> value that gave optimal results. We therefore repeated the
cNMF analysis using <em>k</em> values from 25-35.</p>
<p>Prepping the analysis: (<em>03_cnmf/runPrep2.sh</em>)</p>
<pre><code>#!/bin/bash
#SBATCH -p med
#SBATCH --job-name=prep
#SBATCH -c 4
#SBATCH -t 60-0
#SBATCH --mem=60G
#SBATCH --error=prep2.err
#SBATCH --output=prep2.out

source ~/.bash_profile

conda activate cnmf_env

python ../cNMF/cnmf.py prepare --name neuro_unfilt_fineBroad \
        -c unfilt.whole.raw.counts.tsv \
        -k 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35 \
        --n-iter 200 \
        --total-workers 15 \
        --seed 12345 \
        --tpm unfilt.whole.norm.counts.tsv \
        --genes-file unfilt.whole.genes.tsv</code></pre>
<p>Running the NMF analysis:</p>
<p>(<em>03_cnmf/runFactorize2.sh</em>)</p>
<pre><code>#!/bin/bash
#SBATCH --job-name=factorize
#SBATCH -p med
#SBATCH -c 2
#SBATCH -t 60-0
#SBATCH --array=0-14
#SBATCH --mem=8G
#SBATCH --error=factorizeF_%a.err
#SBATCH --output=factorizeF_%a.out

source ~/.bash_profile

conda activate cnmf_env

python ../cNMF/cnmf.py factorize --name neuro_unfilt_fineBroad --worker-index $SLURM_ARRAY_TASK_ID</code></pre>
<p>Combining separate run files:</p>
<p>(<em>03_cnmf/runCombine2.sh</em>)</p>
<pre><code>#!/bin/bash
#SBATCH --job-name=combine
#SBATCH -p bigmemm 
#SBATCH -c 1
#SBATCH -t 60-0
#SBATCH --mem=24G
#SBATCH --error=combine.err
#SBATCH --output=combine.out

source ~/.bash_profile

conda activate cnmf_env

python ../cNMF/cnmf.py combine --name neuro_unfilt_fineBroad</code></pre>
<p>Generating the error and stability plot:</p>
<p>(<em>03_cnmf/runKselect2.sh</em>)</p>
<pre><code>#!/bin/bash
#SBATCH --job-name=combine
#SBATCH -p bigmemm 
#SBATCH -c 1
#SBATCH -t 60-0
#SBATCH --mem=24G
#SBATCH --error=combine.err
#SBATCH --output=combine.out

source ~/.bash_profile

conda activate cnmf_env

python ../cNMF/cnmf.py k_selection_plot --name neuro_unfilt_fineBroad</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/nmf/neuro_unfilt_fineBroad.k_selection.png"
alt="fine k-selection" /> Based on this plot, we selected a <em>k</em>
value of 56.</p>
<p>The final step of the cNMF analysis is to combine the results from
all 200 runs for a desired <em>k</em> value to generate consensus
results matrices. This step involves filtering out individual outlier
results that don’t closely resemble the overall consensus. To select the
cutoff for removing outliers, we inspected the distribution of a score
that measured the distance of the results from one run to the other runs
that were most similar to it. We generated a plot to examine this
distribution using the consensus function, selecting an initial
threshold of 2.00 (an arbitrarily high value that wouldn’t exclude
anything. Based on the distribution of distances, we selected a cutoff
of 0.13, which captured the bulk of results while excluding the long
tail of outliers:</p>
<p>(<em>03_cnmf/runConsensus2.sh</em>)</p>
<pre><code>#!/bin/bash
#SBATCH --job-name=consensus
#SBATCH -p bigmemm
#SBATCH -c 1
#SBATCH -t 60-0
#SBATCH --mem=24G
#SBATCH --error=consensus.err
#SBATCH --output=consensus.out

source ~/.bash_profile

conda activate cnmf_env

python ../cNMF/cnmf.py consensus --name neuro_unfilt_fineBroad --local-density-threshold 2.00 --components 56 --show-clustering</code></pre>
<p><img
src="resources/01_HydraNeuronAtlas/nmf/neuro_unfilt_fineBroad.clustering.k_27.dt_0_04.png" />
This script generated a number of results files. These included the
<strong>W</strong> matrix
neuro_unfilt_fineBroad.gene_spectra_tpm.k_56.dt_0_13.txt and the
<strong>H</strong> matrix
neuro_unfilt_fineBroad.usages.k_56.dt_0_13.consensus.txt. The other
notable output is the file
neuro_unfilt_fineBroad.gene_spectra_score.k_56.dt_0_13.txt, which
assigns genes Z scores based on how strongly they’re associated with
each metagene.</p>
<h4>
Plotting Metagene Usage in the Hydra Atlas
</h4>
<p>In order to understand the biological function associated with the
metagenes from our NMF analysis, we plotted cell score values (from the
<strong>H</strong> matrix) on our finalized Hydra atlas UMAP.</p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># import NMF cell scores
k27.usage &lt;- read.delim(&quot;/Volumes/HML_MyPassport/JulianoLab/Neuron_Paper/NMF/neuroNMF/neuro_unfilt_fineBroad.usages.k_27.dt_0_04.consensus.txt&quot;, row.names = 1)

#normalize cell score values so that the sum of scores for each cell sums to 1
k27.usage &lt;- t(apply(k27.usage,1,function(x) x/sum(x)))

#add the metagene scores to the Seurat object metadata table
md &lt;- hydra.neuron.seurat@meta.data[,1:13]

md$id &lt;- rownames(md)

k27.usage &lt;- as.data.frame(k27.usage)

colnames(k27.usage) &lt;- gsub(&#39;X&#39;,&#39;mg&#39;,colnames(k27.usage))

k27.usage$id &lt;- rownames(k27.usage)

md &lt;- merge(md, k27.usage, by = &#39;id&#39;, all.x=T)

rownames(md) &lt;- md$id

md$id &lt;- NULL

md &lt;- md[colnames(hydra.neuron.seurat),]

hydra.neuron.seurat@meta.data &lt;- md

# Check it is a valid Seurat object
Idents(hydra.neuron.seurat) &lt;- hydra.neuron.seurat@meta.data$short.ident
validObject(hydra.neuron.seurat) #TRUE
names(hydra.neuron.seurat@meta.data)

# Plot metagenes check
library(Seurat)
library(tidyverse)
library(rstudioapi)
library(glmGamPoi)
library(plotly)
library(RColorBrewer)
library(patchwork)
library(plyr)

#get the names of the metagene columns in the metadata DF
plotMods &lt;- grep(&#39;mg&#39;, colnames(hydra.neuron.seurat@meta.data), value = T)

#plot all metagene cell scores on the atlas UMAP
gg &lt;- FeaturePlot(hydra.neuron.seurat, plotMods[1], order=T) + NoLegend() + NoAxes()

for(i in 2:length(plotMods)){
  subGG &lt;- FeaturePlot(hydra.neuron.seurat, plotMods[i], order=T) + NoLegend() + NoAxes()
  gg &lt;- gg + subGG
}

#how many rows/columns should the plot have?
dims &lt;- sqrt(27)
dims &lt;- c(ceiling(dims),floor(dims))

gg + plot_layout(ncol = dims[1])</code></pre>
<div class="float">
<img src="resources/01_HydraNeuronAtlas/nmf/full.mg.umap.png"
alt="NMF Modules on UMAPs" />
<div class="figcaption">NMF Modules on UMAPs</div>
</div>
<!-- headings -->
<a id="item-seven"></a>
<h3>
Interactive 3D UMAP of Final Hydra Neuron Single Cell Atlas
</h3>
<p>To better visualize connections between differentiated neuron
subtypes and neural progenitors, we created a 3D UMAP of the finalized
hydra.neuron Seurat object. We created a self contained interactive
widget for better exploration of potential transitionary events between
neural progenitors and differentiated neuron subtypes.</p>
<p>(snippet from <em>02_clust/hydra.neuronSeurat.R</em>)</p>
<pre class="r"><code># Creating a 3D UMAP of the Seurat Object-----------------------------------------------------------------
# Load correct libraries
library(plotly)
library(scales)

# Set Ident
Idents(hydra.neuron.seurat) &lt;- &quot;short.ident&quot;

# Run 3D umap
hydra.neuron.seurat &lt;- RunUMAP(object = hydra.neuron.seurat, dims = 1:21, n.components = 3L,
                 reduction.name = &quot;umap_3d&quot;,
                 reduction.key = &quot;UMAP3D_&quot;)

# Save the neuron seurat object with the 3D UMAP coords added (still has the 2D UMAP coords)
saveRDS(hydra.neuron.seurat, &quot;seurat_objects/hydra.neuron.seurat.3Dumap.rds&quot;)

# Extract the UMAP coordinates
umap_3d &lt;- Embeddings(hydra.neuron.seurat, reduction = &quot;umap_3d&quot;)

# fetch short.ident dynamically
short_ident &lt;- FetchData(hydra.neuron.seurat, vars = &quot;short.ident&quot;)$short.ident

# Make a column of row name identities (these will be your cell/barcode names)
umap_3d &lt;- as.data.frame(umap_3d)
umap_3d$label &lt;- paste(rownames(umap_3d))


p &lt;- plot_ly(umap_3d,
             x = ~UMAP3D_1,
             y = ~UMAP3D_2,
             z = ~UMAP3D_3,
             color = short_ident,  # Grouping by short.ident
             colors = hue_pal()(30),      # Customize color palette (optional)
             type = &quot;scatter3d&quot;,
             mode = &quot;markers&quot;,
             marker = list(size = 3),  # Adjust marker size
             text=~label, #This is that extra column we made earlier for which we will use for cell ID
             hoverinfo=&quot;text&quot; #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names
) %&gt;% layout(
  title = &quot;3D UMAP by cell type&quot;,
  scene = list(
    xaxis = list(title = &quot;UMAP1&quot;),
    yaxis = list(title = &quot;UMAP2&quot;),
    zaxis = list(title = &quot;UMAP3&quot;)
  )
)

p
htmlwidgets::saveWidget(widget=p,&quot;seurat_objects/hydra.neuron.seurat_3Dumap.html&quot;, selfcontained = TRUE)</code></pre>
<!-- headings -->
<a id="item-eight"></a>
<h3>
Files Associated with this Document
</h3>
<pre><code>01_hydraNeuronAtlas/
├── 01_mapping
│   ├── cellranger_mkref.sh
                Shell script that makes custom 10x reference (HVAEP1.tran.final.mito.10x.ref)
                using the cellranger pipeline
│   ├── cellranger_count_nG.sh
                Shell script which maps 10X scRNA-seq data collected from 
                non-budding Tg(actin::GFP) animals and creates the counts matrices
│   ├── cellranger_count_bud1.sh
                Shell script which maps 10X scRNA-seq data collected from 
                budding Tg(actin::GFP) animals (ACTIN_GFP_1 library) and 
                creates the counts matrices
│   ├── cellranger_count_bud2.sh
                Shell script which maps 10X scRNA-seq data collected from 
                budding Tg(actin::GFP) animals (ACTIN_GFP_2 library) and 
                creates the counts matrices
│   ├── cellranger_count_PN.sh
                Shell script which maps 10X scRNA-seq data collected from 
                non-budding Tg(tba1c::mNeonGreen) animals and creates the counts matrices
│   ├── HVAEP1.tran.final.mito.10x.ref
                Custom H.vulgaris AEP 10X Reference Directory. 
                Output of cellranger_mkref.sh
│   ├── raw_data
                Directory containing raw sequencing data (fastq) from 10X scRNA-seq 
                collected from FACS sorted neurons from transgenic H.vulgaris AEP
                animals.
│   │   ├── ACTIN_GFP_fastqs
            Directory containing 10X scRNA-seq fastq files for neurons
            FACS sorted from non-budding Tg(actin::GFP) animals
│   │   ├── budding_fastq
            Directory containing 10X scRNA-seq fastq files for neurons
            FACS sorted from budding Tg(actin::GFP) animals.
            2 libraries collected: ACTIN_GFP_1 &amp; ACTIN_GFP_2
│   │   ├── PN_fastqs
            Directory containing 10X scRNA-seq fastq files for neurons
            FACS sorted from Tg(tba1c::mNeonGreen) animals
│   ├── resources
│   │   ├── HVAEP1.tran.final.mito.fasta
            Multi-fasta file containing the nucleotide sequences for the longest 
            isoform from each AEP gene model as well as the sequences for all
            Hydra mitochondrial genes. Used as a reference for 10X library
│   │   ├── HVAEP1.transcriptome.mito.gtf
                    Modified version of HVAEP1.transcriptome.gtf with mitochondrial genes
                    added. Used as a reference for 10X library mapping.
│   ├── budding1_10x_HVAEP1_tran_final
            Output directory for cellranger_count_bud1.sh containing counts matrices
│   ├── budding2_10x_HVAEP1_tran_final
            Output directory for cellranger_count_bud2.sh containing counts matrices
│   ├── nGreen_10x_HVAEP1_tran_final
            Output directory for cellranger_count_nG.sh containing counts matrices
│   ├── PN_10x_HVAEP1_tran_final
            Output directory for cellranger_count_PN.sh containing counts matrices
├── 02_clust
│   ├── hydra.neuronSeurat.R
                R script that performs the QC, filtering, clustering, and labeling of the 
                AEP-mapped hydra neuron single cell atlas. Preps the input for an NMF analysis.
                Adds metagene metadata from NMF analysis to the annotated Seurat boject.
                Creates a 3D umap of finalized hydra.neuron.seurat.rds object
│   ├── resources
│   │   ├── hy.neuro_markers.csv
            Neuron subtype molecular markers identified and validated in this study.
│   │   ├── known.markers.csv
            Molecular markers for previously identified neuron types/subtypes from the original
            hydra single cell atlas study (Siebert 2019) and remapped/realnalyzed in (Cazet 2023).
│   │   ├── nonDubLabeledSeurat.rds 
            R data file containing the clustering results for the AEP-mapped whole Hydra single 
            cell atlas collected in Siebert 2019 and remapped in Cazet 2023.
│   ├── seurat_objects
        Directory for temporary seurat object and finalized seurat objects
│   │   ├── hydra.neuron.seurat.rds
            R data file containing the finalized clustering results for the AEP-mapped 
            hydra neuron single cell atlas with descriptive cell-type labels in a Seurat object format.
│   │   ├── hydra.neuron.seurat.3Dumap.rds
            R data file containing the 3D clustering results for the AEP-mapped hydra neuron 
            single cell atlas with descriptive cell-type labels in a Seurat object format.
            Used as the input for the interactive hydra.neuron.seurat_3Dumap.html widget.
│   │   ├── hydra.neuron.seurat_3Dumap.html
            Interactive widget for visualizing AEP-mapped hydra neuron single cell atlas clustering
            in 3-dimensions.
│   │   ├── hydra.neuron.seurat_3Dumap_files
            Directory containing all files required for launching hydra.neuron.seurat_3Dumap.html
│   ├── unprocessed_data
        Directory containing the ouptus of cellranger_count for each 10X scRNA-seq library collected 
        in this study
│   │   ├── budding1_filtered_feature_bc_matrix
            Directory containing a matrix.mtx, genes.tsv (or features.tsv), and barcodes.tsv files outputs
            of cellranger_arc for Tg(actin::GFP) budding 1 library. Directory from 
            01_mapping/budding1_10x_HVAEP1_tran_final/outs/filtered_feature_bc_matrix
│   │   ├── budding2_filtered_feature_bc_matrix
            Directory containing a matrix.mtx, genes.tsv (or features.tsv), and barcodes.tsv files outputs
            of cellranger_arc for Tg(actin::GFP) budding 2 library. Directory from 
            01_mapping/budding2_10x_HVAEP1_tran_final/outs/filtered_feature_bc_matrix
│   │   ├── nonbudding_filtered_feature_bc_matrix
            Directory containing a matrix.mtx, genes.tsv (or features.tsv), and barcodes.tsv files outputs
            of cellranger_arc for Tg(actin::GFP) nonbudding library. Directory from 
            01_mapping/nGreen_10x_HVAEP1_tran_final/outs/filtered_feature_bc_matrix
│   │   ├── tba1c_filtered_feature_bc_matrix
            Directory containing a matrix.mtx, genes.tsv (or features.tsv), and barcodes.tsv files outputs
            of cellranger_arc for Tg(tba1c::mNeonGreen) nonbudding library. Directory from 
            01_mapping/PN_10x_HVAEP1_tran_final/outs/filtered_feature_bc_matrix
├── 03_cnmf
│   ├── runCombine2.sh
                Shell script that pools the individual files created by separate
                parallelized nmf runs generated as part of the fine resolution K 
                parameter sweep.
│   ├── runCombine.sh
                Shell script that pools the individual files created by separate
                parallelized nmf runs generated as part of the broad resolution K 
                parameter sweep.
│   ├── runConseunsus2.sh
                Shell script that calculates factorization matrices based on the 
                consensus of independent replicates for a given K value (in this 
                case, K=56).
│   ├── runFactorize2.sh
                Shell script that performs NMF across a relatively narrow range of 
                K values (K=50-60 by steps of 1). The script performs 200 independent 
                NMF calculations for each specified K value.
│   ├── runFactorize.sh
                Shell script that performs NMF across a relatively broad range of 
                K values (K=15-90 by steps of 5). The script performs 200 independent 
                NMF calculations for each specified K value.
│   ├── runKselect2.sh
                Shell script that calculates and plots both error and stability
                scores for different K values based on the results of runFactorize2.sh
                (K=50-60 by steps of 1). 
│   ├── runKselect.sh
                Shell script that calculates and plots both error and stability
                scores for different K values based on the results of runFactorize.sh
                (K=15-90 by steps of 5).
│   ├── runPrep2.sh
                Shell script that sets up the separate parallelized NMF runs across
                a relatiely narrow range of K values (K=50-60 by steps of 1). 
│   ├── runPrep.sh
                Shell script that sets up the separate parallelized NMF runs across
                a relatiely narrow range of K values (K=15-90 by steps of 5). 
│   ├── neuro_unfilt_fineBroad.gene_spectra_score.k_27.dt_0_04.txt
                Matrix generated by runConseunsus2.sh that contains metagene Z-scores for
                each gene included in the hydra atlas. A Higher z-scores indicates a 
                stronger associations between a gene and the metagene.
│   ├── neuro_unfilt_fineBroad.gene_spectra_tpm.k_27.dt_0_04.txt
                Matrix generated by runConseunsus2.sh that contains the gene score matrix
                calculated by NMF that, when multiplied by the cell score matrix, approximates
                the values in the normalized expression matrix provided as input
                (unfilt.neuron.norm.counts.tsv).
│   ├── neuro_unfilt_fineBroad.spectra.k_27.dt_0_04.consensus.txt
                Matrix generated by runConseunsus2.sh that contains the gene score matrix
                calculated by NMF that, when multiplied by the cell score matrix, approximates
                the values in the raw expression matrix provided as input
                (unfilt.neuro.raw.counts.tsv).
│   ├── neuro_unfilt_fineBroad.usages.k_27.dt_0_04.consensus.txt
                Matrix generated by runConseunsus2.sh that contains the cell score matrix
                calculated by NMF. Higher values for a metagene in a given cell indicates that
                the metagene in question contributes more strongly to the cell&#39;s transcriptional
                profile.
│   ├── neuro_unfilt_fineBroad.clustering.k_27.dt_0_04.png
                Output generated by runConseunsus2.sh. Shows the results of a clustering
                analysis grouping together the 200 independent runs from the NMF analysis
                where K was set to 27. Used to select a distance cutoff to remove outlier
                NMF replicates and to generate a final set of consensus matrices.
│   ├── unfilt.neuron.genes.tsv
                List of variable gene IDs that were used for the NMF analysis of the
                hydra neuron single-cell atlas (taken from hydra.neuron.seurat.rds)
│   ├── unfilt.neuron.norm.counts.tsv
                Digital gene expression matrix containing Seurat-normalized read counts
                for the hydra neuorn single-cell atlas (taken from hydra.neuron.seurat.rds)
│   ├── unfilt.neuro.raw.counts.tsv
                Digital gene expression matrix containing raw read counts for the hydra 
                neuron single-cell atlas (taken from hydra.neuron.seurat.rds)</code></pre>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
